{"version":3,"file":"StoriesFrame.js","sourceRoot":"","sources":["../../../src/components/StoriesFrame.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,UAAU,EAAE,MAAM,KAAK,CAAC;AAE5C,OAAO,EAAE,aAAa,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAGzD,OAAO,EAAE,SAAS,EAAE,GAAG,EAAE,MAAM,uBAAuB,CAAC;AAEvD,8CAA8C;AAG9C,IAAa,YAAY,GAAzB,MAAa,YAAa,SAAQ,UAAU;IAA5C;;QAiBE,YAAO,GAAyB,SAAS,EAAE,CAAC;QAGlC,aAAQ,GAAuB,SAAS,CAAC;QAgCnD,wBAAwB;QACxB,0DAA0D;QAC1D,kDAAkD;QAChD,+DAA+D;QACjE,IAAI;QAEJ,aAAa;QACb,iBAAiB;QACjB,uDAAuD;QACvD,wBAAwB;QACxB,gBAAgB;QAChB,OAAO;QACP,IAAI;QAEJ,iCAAiC;QACjC,iBAAiB;QACjB,IAAI;QAEI,eAAU,GAAG,CAAC,CAAQ,EAAE,EAAE;YAChC,sCAAsC;YACtC,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC3B,CAAC,CAAA;IACH,CAAC;IApDC,8DAA8D;IAE9D,iCAAiC;IACjC,iCAAiC;IACjC,IAAI;IAEJ,MAAM;QACJ,OAAO,IAAI,CAAA;cACD,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,gBAAgB,IAAI,CAAC,UAAU;KACzD,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACO,KAAK,CAAC,UAAU;;QACxB,0DAA0D;QAC1D,2DAA2D;QAC3D,MAAM,OAAO,GAAG,MAAA,IAAI,CAAC,OAAO,CAAC,KAAK,0CAAE,aAAa,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;QACrE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,sCAAsC;QACtC,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC7D,MAAM,OAAO,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;CAwBF,CAAA;AAzEQ,mBAAM,GAAG,GAAG,CAAA;;;;;;;;;;;GAWlB,CAAC;AAEF,oCAAoC;AAC7B,8BAAiB,GAAG,EAAC,GAAG,UAAU,CAAC,iBAAiB,EAAE,IAAI,EAAE,QAA0B,EAAE,CAAA;AAK/F;IADC,KAAK,EAAE;8CAC2C;AApBxC,YAAY;IADxB,aAAa,CAAC,eAAe,CAAC;GAClB,YAAY,CA0ExB;SA1EY,YAAY","sourcesContent":["import { html, css, LitElement } from 'lit';\nimport type { TemplateResult } from 'lit';\nimport { customElement, state } from 'lit/decorators.js';\n// import { property } from 'lit/decorators.js';\nimport type { Ref } from 'lit/directives/ref.js';\nimport { createRef, ref } from 'lit/directives/ref.js';\n\n// import { StoryObjects } from '../types.js';\n\n@customElement('stories-frame')\nexport class StoriesFrame extends LitElement {\n  static styles = css`\n    :host {\n      display: block;\n      padding: 25px;\n      color: var(--todo-list-text-color, #000);\n    }\n\n    iframe {\n      width: 100%;\n      height: 100%;\n    }\n  `;\n\n  // eslint-disable-next-line no-undef\n  static shadowRootOptions = {...LitElement.shadowRootOptions, mode: 'closed' as ShadowRootMode};\n\n  slotRef: Ref<HTMLSlotElement> = createRef();\n\n  @state()\n  protected _content: Node[] | undefined = undefined;\n\n  // @property({ type: Object }) story: StoryObject | undefined;\n\n  // private onLoad(event: Event) {\n  //   console.log('OnLoad', event)\n  // }\n\n  render(): TemplateResult {\n    return html`\n      <slot ${ref(this.slotRef)} @slotchange=${this.slotchange}></slot>\n    `;\n  }\n\n  /**\n   * Although slotchange isn't generally a user-driven event, it's\n   * impossible for us to know whether a change in slot content is going\n   * to result in effects that the host of this element can predict.\n   * To be on the safe side, we raise any change events that come up\n   * during the processing of this event.\n   */\n  protected async slotchange(): Promise<void> {\n    // The nodes assigned to the given component have changed.\n    // Update the component's state to reflect the new content.\n    const content = this.slotRef.value?.assignedNodes({ flatten: true });\n    Object.freeze(content);\n    this._content = content;\n    // eslint-disable-next-line no-console\n    console.log('slotchange', this.slotRef.value, this._content);\n    await Promise.resolve();\n  }\n\n  // connectedCallback() {\n  //   const shadow = this.attachShadow({ mode: 'closed' });\n  //   shadow.innerHTML = this.getAttribute('html');\n    // this.renderRoot.innerHTML = this.getAttribute('html') || '';\n  // }\n\n  // render() {\n  //   return html`\n  //     <iframe title=\"iframe\" @load=${this.handleLoad}>\n  //       <div>Test</div>\n  //     </iframe>\n  //   `;\n  // }\n\n  // protected createRenderRoot() {\n  //   return this;\n  // }\n\n  private handleLoad = (e: Event) => {\n    // eslint-disable-next-line no-console\n    console.log('Loaded', e);\n  }\n}\n/*\nexport default function StoriesFrame({children}: Props): VNode {\n    const frame = useRef(null);\n\n    const onLoad = (evt: Event) => {\n        console.log('On Load', evt);\n        if (frame.current) {\n            let target = frame.current as any;\n            let childNodes = target.childNodes;\n            if (childNodes.length === 1 && childNodes[0].tagName === 'SLOT') {\n                target = childNodes[0];\n                childNodes = childNodes[0].childNodes;\n            }\n            const body = (frame.current as any).contentDocument.body;\n            const el = document.createElement(\"DIV\"); // we will mount or nested app to this element\n            body.appendChild(el);\n            childNodes.forEach(child => {\n                console.log(child, child.tagName);\n                target.removeChild(child);\n                el.appendChild(child)\n            });\n        }\n    };\n\n    return (\n        <iframe ref={frame} style={{width: '100%', height: '100%'}} onLoad={onLoad}>\n            { children }\n        </iframe>\n    );\n}\n*/\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"stories-frame\": StoriesFrame,\n  }\n}\n"]}