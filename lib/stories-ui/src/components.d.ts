/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ActionEvent, ActionItem, ActionItems, CheckboxChangeEventDetail, Color, Commands, InputChangeEventDetail, RouterDirection, SearchbarChangeEventDetail, StyleEventDetail, TabBarChangedEventDetail, TabButtonClickEventDetail, TabButtonLayout, TextFieldTypes, ToolEvent } from "./types";
import { Addon, AddonState } from ".";
import { StoryComponent, StoryModules } from "@stories/stories-common";
import { StoriesStateType } from "./store";
export namespace Components {
    interface StoriesActionBar {
        /**
          * Action items
         */
        "actionItems": ActionItems;
    }
    interface StoriesActionButton {
        /**
          * ActionItem property
         */
        "actionItem": ActionItem;
    }
    interface StoriesAddonActions {
    }
    interface StoriesAddonControls {
    }
    interface StoriesAddons {
        "findAddon": (id: string) => Promise<Addon<AddonState>>;
        "registerAddon": (addon: Addon<AddonState>, defaultState?: AddonState) => Promise<void>;
    }
    interface StoriesApp {
        /**
          * Story Modules
         */
        "modules": StoryModules;
        /**
          * Story Modules
         */
        "store": StoriesStateType;
    }
    interface StoriesBadge {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
    }
    interface StoriesButton {
        /**
          * The type of button.
         */
        "buttonType": string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled": boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Set to `"clear"` for a transparent button, to `"outline"` for a transparent button with a border, or to `"solid"`. The default style is `"solid"` except inside of a toolbar, where the default is `"clear"`.
         */
        "fill"?: 'clear' | 'outline' | 'solid' | 'default';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
         */
        "href": string | undefined;
        /**
          * When using a router, it specifies the transition direction when navigating to another page using `href`.
         */
        "routerDirection": RouterDirection;
        /**
          * The button shape.
         */
        "shape"?: 'round';
        /**
          * The button size.
         */
        "size"?: 'small' | 'default' | 'large';
        /**
          * If `true`, activates a button with a heavier font weight.
         */
        "strong": boolean;
        /**
          * Specifies where to display the linked URL. Only applies when an `href` is provided. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target": string | undefined;
        /**
          * The type of the button.
         */
        "type": 'submit' | 'reset' | 'button';
    }
    interface StoriesButtons {
        /**
          * If true, buttons will disappear when its parent toolbar has fully collapsed if the toolbar is not the first toolbar. If the toolbar is the first toolbar, the buttons will be hidden and will only be shown once all toolbars have fully collapsed.
         */
        "collapse": boolean;
    }
    interface StoriesCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * If `true`, the user cannot interact with the checkbox.
         */
        "disabled": boolean;
        /**
          * If `true`, the checkbox will visually appear as indeterminate.
         */
        "indeterminate": boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * The value of the checkbox does not mean if it's checked or not, use the `checked` property for that.  The value of a checkbox is analogous to the value of an `<input type="checkbox">`, it's only used when the checkbox participates in a native `<form>`.
         */
        "value": any | null;
    }
    interface StoriesCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StoriesFooter {
    }
    interface StoriesGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed": boolean;
    }
    interface StoriesIcon {
        /**
          * Icon name
         */
        "name": string;
    }
    interface StoriesInput {
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput": boolean;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value. This property applies only when the `type` property is set to `"email"`, `"number"`, `"password"`, `"search"`, `"tel"`, `"text"`, or `"url"`, otherwise it is ignored.
         */
        "placeholder"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * Sets blur on the native `input` in `stories-input`. Use this method instead of the global `input.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the native `input` in `stories-input`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The initial size of the control. This value is in pixels unless the value of the type attribute is `"text"` or `"password"`, in which case it is an integer number of characters. This attribute applies only when the `type` attribute is set to `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
         */
        "size"?: number;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface StoriesLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StoriesPreview {
    }
    interface StoriesRouter {
    }
    interface StoriesRow {
    }
    interface StoriesSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon": string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder": string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets focus on the specified `stories-searchbar`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton": 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton": 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type": 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StoriesSidebar {
    }
    interface StoriesSplitPane {
        "defaultSize": number;
        "isResizing": boolean;
        "minSize": number;
        "split": "horizontal" | "vertical";
    }
    interface StoriesTab {
        "active": boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StoriesTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StoriesTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled": boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * The selected tab component
         */
        "selected": boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StoriesTabs {
        /**
          * Get the currently selected tab.
         */
        "getSelected": () => Promise<string | undefined>;
        /**
          * Get a specific tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "getTab": (tab: string | HTMLStoriesTabElement) => Promise<HTMLStoriesTabElement | undefined>;
        /**
          * Select a tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "select": (tab: string | HTMLStoriesTabElement) => Promise<boolean>;
    }
    interface StoriesToolBar {
    }
    interface StoriesToolButton {
        /**
          * command property
         */
        "command": Commands;
        /**
          * disabled property
         */
        "disabled": boolean;
        /**
          * icon property
         */
        "icon": string;
    }
    interface StoriesToolZoom {
    }
    interface StoriesZoom {
        "zoom": number;
    }
}
declare global {
    interface HTMLStoriesActionBarElement extends Components.StoriesActionBar, HTMLStencilElement {
    }
    var HTMLStoriesActionBarElement: {
        prototype: HTMLStoriesActionBarElement;
        new (): HTMLStoriesActionBarElement;
    };
    interface HTMLStoriesActionButtonElement extends Components.StoriesActionButton, HTMLStencilElement {
    }
    var HTMLStoriesActionButtonElement: {
        prototype: HTMLStoriesActionButtonElement;
        new (): HTMLStoriesActionButtonElement;
    };
    interface HTMLStoriesAddonActionsElement extends Components.StoriesAddonActions, HTMLStencilElement {
    }
    var HTMLStoriesAddonActionsElement: {
        prototype: HTMLStoriesAddonActionsElement;
        new (): HTMLStoriesAddonActionsElement;
    };
    interface HTMLStoriesAddonControlsElement extends Components.StoriesAddonControls, HTMLStencilElement {
    }
    var HTMLStoriesAddonControlsElement: {
        prototype: HTMLStoriesAddonControlsElement;
        new (): HTMLStoriesAddonControlsElement;
    };
    interface HTMLStoriesAddonsElement extends Components.StoriesAddons, HTMLStencilElement {
    }
    var HTMLStoriesAddonsElement: {
        prototype: HTMLStoriesAddonsElement;
        new (): HTMLStoriesAddonsElement;
    };
    interface HTMLStoriesAppElement extends Components.StoriesApp, HTMLStencilElement {
    }
    var HTMLStoriesAppElement: {
        prototype: HTMLStoriesAppElement;
        new (): HTMLStoriesAppElement;
    };
    interface HTMLStoriesBadgeElement extends Components.StoriesBadge, HTMLStencilElement {
    }
    var HTMLStoriesBadgeElement: {
        prototype: HTMLStoriesBadgeElement;
        new (): HTMLStoriesBadgeElement;
    };
    interface HTMLStoriesButtonElement extends Components.StoriesButton, HTMLStencilElement {
    }
    var HTMLStoriesButtonElement: {
        prototype: HTMLStoriesButtonElement;
        new (): HTMLStoriesButtonElement;
    };
    interface HTMLStoriesButtonsElement extends Components.StoriesButtons, HTMLStencilElement {
    }
    var HTMLStoriesButtonsElement: {
        prototype: HTMLStoriesButtonsElement;
        new (): HTMLStoriesButtonsElement;
    };
    interface HTMLStoriesCheckboxElement extends Components.StoriesCheckbox, HTMLStencilElement {
    }
    var HTMLStoriesCheckboxElement: {
        prototype: HTMLStoriesCheckboxElement;
        new (): HTMLStoriesCheckboxElement;
    };
    interface HTMLStoriesColElement extends Components.StoriesCol, HTMLStencilElement {
    }
    var HTMLStoriesColElement: {
        prototype: HTMLStoriesColElement;
        new (): HTMLStoriesColElement;
    };
    interface HTMLStoriesFooterElement extends Components.StoriesFooter, HTMLStencilElement {
    }
    var HTMLStoriesFooterElement: {
        prototype: HTMLStoriesFooterElement;
        new (): HTMLStoriesFooterElement;
    };
    interface HTMLStoriesGridElement extends Components.StoriesGrid, HTMLStencilElement {
    }
    var HTMLStoriesGridElement: {
        prototype: HTMLStoriesGridElement;
        new (): HTMLStoriesGridElement;
    };
    interface HTMLStoriesIconElement extends Components.StoriesIcon, HTMLStencilElement {
    }
    var HTMLStoriesIconElement: {
        prototype: HTMLStoriesIconElement;
        new (): HTMLStoriesIconElement;
    };
    interface HTMLStoriesInputElement extends Components.StoriesInput, HTMLStencilElement {
    }
    var HTMLStoriesInputElement: {
        prototype: HTMLStoriesInputElement;
        new (): HTMLStoriesInputElement;
    };
    interface HTMLStoriesLabelElement extends Components.StoriesLabel, HTMLStencilElement {
    }
    var HTMLStoriesLabelElement: {
        prototype: HTMLStoriesLabelElement;
        new (): HTMLStoriesLabelElement;
    };
    interface HTMLStoriesPreviewElement extends Components.StoriesPreview, HTMLStencilElement {
    }
    var HTMLStoriesPreviewElement: {
        prototype: HTMLStoriesPreviewElement;
        new (): HTMLStoriesPreviewElement;
    };
    interface HTMLStoriesRouterElement extends Components.StoriesRouter, HTMLStencilElement {
    }
    var HTMLStoriesRouterElement: {
        prototype: HTMLStoriesRouterElement;
        new (): HTMLStoriesRouterElement;
    };
    interface HTMLStoriesRowElement extends Components.StoriesRow, HTMLStencilElement {
    }
    var HTMLStoriesRowElement: {
        prototype: HTMLStoriesRowElement;
        new (): HTMLStoriesRowElement;
    };
    interface HTMLStoriesSearchbarElement extends Components.StoriesSearchbar, HTMLStencilElement {
    }
    var HTMLStoriesSearchbarElement: {
        prototype: HTMLStoriesSearchbarElement;
        new (): HTMLStoriesSearchbarElement;
    };
    interface HTMLStoriesSidebarElement extends Components.StoriesSidebar, HTMLStencilElement {
    }
    var HTMLStoriesSidebarElement: {
        prototype: HTMLStoriesSidebarElement;
        new (): HTMLStoriesSidebarElement;
    };
    interface HTMLStoriesSplitPaneElement extends Components.StoriesSplitPane, HTMLStencilElement {
    }
    var HTMLStoriesSplitPaneElement: {
        prototype: HTMLStoriesSplitPaneElement;
        new (): HTMLStoriesSplitPaneElement;
    };
    interface HTMLStoriesTabElement extends Components.StoriesTab, HTMLStencilElement {
    }
    var HTMLStoriesTabElement: {
        prototype: HTMLStoriesTabElement;
        new (): HTMLStoriesTabElement;
    };
    interface HTMLStoriesTabBarElement extends Components.StoriesTabBar, HTMLStencilElement {
    }
    var HTMLStoriesTabBarElement: {
        prototype: HTMLStoriesTabBarElement;
        new (): HTMLStoriesTabBarElement;
    };
    interface HTMLStoriesTabButtonElement extends Components.StoriesTabButton, HTMLStencilElement {
    }
    var HTMLStoriesTabButtonElement: {
        prototype: HTMLStoriesTabButtonElement;
        new (): HTMLStoriesTabButtonElement;
    };
    interface HTMLStoriesTabsElement extends Components.StoriesTabs, HTMLStencilElement {
    }
    var HTMLStoriesTabsElement: {
        prototype: HTMLStoriesTabsElement;
        new (): HTMLStoriesTabsElement;
    };
    interface HTMLStoriesToolBarElement extends Components.StoriesToolBar, HTMLStencilElement {
    }
    var HTMLStoriesToolBarElement: {
        prototype: HTMLStoriesToolBarElement;
        new (): HTMLStoriesToolBarElement;
    };
    interface HTMLStoriesToolButtonElement extends Components.StoriesToolButton, HTMLStencilElement {
    }
    var HTMLStoriesToolButtonElement: {
        prototype: HTMLStoriesToolButtonElement;
        new (): HTMLStoriesToolButtonElement;
    };
    interface HTMLStoriesToolZoomElement extends Components.StoriesToolZoom, HTMLStencilElement {
    }
    var HTMLStoriesToolZoomElement: {
        prototype: HTMLStoriesToolZoomElement;
        new (): HTMLStoriesToolZoomElement;
    };
    interface HTMLStoriesZoomElement extends Components.StoriesZoom, HTMLStencilElement {
    }
    var HTMLStoriesZoomElement: {
        prototype: HTMLStoriesZoomElement;
        new (): HTMLStoriesZoomElement;
    };
    interface HTMLElementTagNameMap {
        "stories-action-bar": HTMLStoriesActionBarElement;
        "stories-action-button": HTMLStoriesActionButtonElement;
        "stories-addon-actions": HTMLStoriesAddonActionsElement;
        "stories-addon-controls": HTMLStoriesAddonControlsElement;
        "stories-addons": HTMLStoriesAddonsElement;
        "stories-app": HTMLStoriesAppElement;
        "stories-badge": HTMLStoriesBadgeElement;
        "stories-button": HTMLStoriesButtonElement;
        "stories-buttons": HTMLStoriesButtonsElement;
        "stories-checkbox": HTMLStoriesCheckboxElement;
        "stories-col": HTMLStoriesColElement;
        "stories-footer": HTMLStoriesFooterElement;
        "stories-grid": HTMLStoriesGridElement;
        "stories-icon": HTMLStoriesIconElement;
        "stories-input": HTMLStoriesInputElement;
        "stories-label": HTMLStoriesLabelElement;
        "stories-preview": HTMLStoriesPreviewElement;
        "stories-router": HTMLStoriesRouterElement;
        "stories-row": HTMLStoriesRowElement;
        "stories-searchbar": HTMLStoriesSearchbarElement;
        "stories-sidebar": HTMLStoriesSidebarElement;
        "stories-split-pane": HTMLStoriesSplitPaneElement;
        "stories-tab": HTMLStoriesTabElement;
        "stories-tab-bar": HTMLStoriesTabBarElement;
        "stories-tab-button": HTMLStoriesTabButtonElement;
        "stories-tabs": HTMLStoriesTabsElement;
        "stories-tool-bar": HTMLStoriesToolBarElement;
        "stories-tool-button": HTMLStoriesToolButtonElement;
        "stories-tool-zoom": HTMLStoriesToolZoomElement;
        "stories-zoom": HTMLStoriesZoomElement;
    }
}
declare namespace LocalJSX {
    interface StoriesActionBar {
        /**
          * Action items
         */
        "actionItems"?: ActionItems;
    }
    interface StoriesActionButton {
        /**
          * ActionItem property
         */
        "actionItem": ActionItem;
        /**
          * Action Event
         */
        "onStories-action"?: (event: CustomEvent<ActionEvent>) => void;
    }
    interface StoriesAddonActions {
    }
    interface StoriesAddonControls {
    }
    interface StoriesAddons {
    }
    interface StoriesApp {
        /**
          * Story Modules
         */
        "modules"?: StoryModules;
        "onStoryChange"?: (event: CustomEvent<StoryComponent>) => void;
        /**
          * Story Modules
         */
        "store"?: StoriesStateType;
    }
    interface StoriesBadge {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
    }
    interface StoriesButton {
        /**
          * The type of button.
         */
        "buttonType"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled"?: boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Set to `"clear"` for a transparent button, to `"outline"` for a transparent button with a border, or to `"solid"`. The default style is `"solid"` except inside of a toolbar, where the default is `"clear"`.
         */
        "fill"?: 'clear' | 'outline' | 'solid' | 'default';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
         */
        "href"?: string | undefined;
        /**
          * Emitted when the button loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the button click.
         */
        "onStoriesClick"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the button has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * When using a router, it specifies the transition direction when navigating to another page using `href`.
         */
        "routerDirection"?: RouterDirection;
        /**
          * The button shape.
         */
        "shape"?: 'round';
        /**
          * The button size.
         */
        "size"?: 'small' | 'default' | 'large';
        /**
          * If `true`, activates a button with a heavier font weight.
         */
        "strong"?: boolean;
        /**
          * Specifies where to display the linked URL. Only applies when an `href` is provided. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target"?: string | undefined;
        /**
          * The type of the button.
         */
        "type"?: 'submit' | 'reset' | 'button';
    }
    interface StoriesButtons {
        /**
          * If true, buttons will disappear when its parent toolbar has fully collapsed if the toolbar is not the first toolbar. If the toolbar is the first toolbar, the buttons will be hidden and will only be shown once all toolbars have fully collapsed.
         */
        "collapse"?: boolean;
    }
    interface StoriesCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * If `true`, the user cannot interact with the checkbox.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the checkbox will visually appear as indeterminate.
         */
        "indeterminate"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the checkbox loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the checked property has changed.
         */
        "onStoriesChange"?: (event: CustomEvent<CheckboxChangeEventDetail>) => void;
        /**
          * Emitted when the checkbox has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the styles change.
         */
        "onStoriesStyle"?: (event: CustomEvent<StyleEventDetail>) => void;
        /**
          * The value of the checkbox does not mean if it's checked or not, use the `checked` property for that.  The value of a checkbox is analogous to the value of an `<input type="checkbox">`, it's only used when the checkbox participates in a native `<form>`.
         */
        "value"?: any | null;
    }
    interface StoriesCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StoriesFooter {
    }
    interface StoriesGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed"?: boolean;
    }
    interface StoriesIcon {
        /**
          * Icon name
         */
        "name"?: string;
    }
    interface StoriesInput {
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput"?: boolean;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onStoriesChange"?: (event: CustomEvent<InputChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onStoriesInput"?: (event: CustomEvent<InputEvent>) => void;
        /**
          * Emitted when the styles change.
         */
        "onStoriesStyle"?: (event: CustomEvent<StyleEventDetail>) => void;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value. This property applies only when the `type` property is set to `"email"`, `"number"`, `"password"`, `"search"`, `"tel"`, `"text"`, or `"url"`, otherwise it is ignored.
         */
        "placeholder"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * The initial size of the control. This value is in pixels unless the value of the type attribute is `"text"` or `"password"`, in which case it is an integer number of characters. This attribute applies only when the `type` attribute is set to `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
         */
        "size"?: number;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface StoriesLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StoriesPreview {
    }
    interface StoriesRouter {
    }
    interface StoriesRow {
    }
    interface StoriesSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon"?: string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Emitted when the input loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the cancel button is clicked.
         */
        "onStoriesCancel"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onStoriesChange"?: (event: CustomEvent<SearchbarChangeEventDetail>) => void;
        /**
          * Emitted when the clear input button is clicked.
         */
        "onStoriesClear"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onStoriesInput"?: (event: CustomEvent<KeyboardEvent>) => void;
        /**
          * Emitted when the styles change.
         */
        "onStoriesStyle"?: (event: CustomEvent<StyleEventDetail>) => void;
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder"?: string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton"?: 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton"?: 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type"?: 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StoriesSidebar {
    }
    interface StoriesSplitPane {
        "defaultSize"?: number;
        "isResizing"?: boolean;
        "minSize"?: number;
        "onStoriesSizeChange"?: (event: CustomEvent<number>) => void;
        "split"?: "horizontal" | "vertical";
    }
    interface StoriesTab {
        "active"?: boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StoriesTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        "onStoriesTabBarChange"?: (event: CustomEvent<TabBarChangedEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StoriesTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled"?: boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * Emitted when the tab bar is clicked
         */
        "onStoriesTabButtonClick"?: (event: CustomEvent<TabButtonClickEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selected"?: boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StoriesTabs {
    }
    interface StoriesToolBar {
    }
    interface StoriesToolButton {
        /**
          * command property
         */
        "command"?: Commands;
        /**
          * disabled property
         */
        "disabled"?: boolean;
        /**
          * icon property
         */
        "icon"?: string;
        /**
          * Action Event
         */
        "onStoriesAction"?: (event: CustomEvent<ToolEvent>) => void;
    }
    interface StoriesToolZoom {
    }
    interface StoriesZoom {
        "zoom"?: number;
    }
    interface IntrinsicElements {
        "stories-action-bar": StoriesActionBar;
        "stories-action-button": StoriesActionButton;
        "stories-addon-actions": StoriesAddonActions;
        "stories-addon-controls": StoriesAddonControls;
        "stories-addons": StoriesAddons;
        "stories-app": StoriesApp;
        "stories-badge": StoriesBadge;
        "stories-button": StoriesButton;
        "stories-buttons": StoriesButtons;
        "stories-checkbox": StoriesCheckbox;
        "stories-col": StoriesCol;
        "stories-footer": StoriesFooter;
        "stories-grid": StoriesGrid;
        "stories-icon": StoriesIcon;
        "stories-input": StoriesInput;
        "stories-label": StoriesLabel;
        "stories-preview": StoriesPreview;
        "stories-router": StoriesRouter;
        "stories-row": StoriesRow;
        "stories-searchbar": StoriesSearchbar;
        "stories-sidebar": StoriesSidebar;
        "stories-split-pane": StoriesSplitPane;
        "stories-tab": StoriesTab;
        "stories-tab-bar": StoriesTabBar;
        "stories-tab-button": StoriesTabButton;
        "stories-tabs": StoriesTabs;
        "stories-tool-bar": StoriesToolBar;
        "stories-tool-button": StoriesToolButton;
        "stories-tool-zoom": StoriesToolZoom;
        "stories-zoom": StoriesZoom;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "stories-action-bar": LocalJSX.StoriesActionBar & JSXBase.HTMLAttributes<HTMLStoriesActionBarElement>;
            "stories-action-button": LocalJSX.StoriesActionButton & JSXBase.HTMLAttributes<HTMLStoriesActionButtonElement>;
            "stories-addon-actions": LocalJSX.StoriesAddonActions & JSXBase.HTMLAttributes<HTMLStoriesAddonActionsElement>;
            "stories-addon-controls": LocalJSX.StoriesAddonControls & JSXBase.HTMLAttributes<HTMLStoriesAddonControlsElement>;
            "stories-addons": LocalJSX.StoriesAddons & JSXBase.HTMLAttributes<HTMLStoriesAddonsElement>;
            "stories-app": LocalJSX.StoriesApp & JSXBase.HTMLAttributes<HTMLStoriesAppElement>;
            "stories-badge": LocalJSX.StoriesBadge & JSXBase.HTMLAttributes<HTMLStoriesBadgeElement>;
            "stories-button": LocalJSX.StoriesButton & JSXBase.HTMLAttributes<HTMLStoriesButtonElement>;
            "stories-buttons": LocalJSX.StoriesButtons & JSXBase.HTMLAttributes<HTMLStoriesButtonsElement>;
            "stories-checkbox": LocalJSX.StoriesCheckbox & JSXBase.HTMLAttributes<HTMLStoriesCheckboxElement>;
            "stories-col": LocalJSX.StoriesCol & JSXBase.HTMLAttributes<HTMLStoriesColElement>;
            "stories-footer": LocalJSX.StoriesFooter & JSXBase.HTMLAttributes<HTMLStoriesFooterElement>;
            "stories-grid": LocalJSX.StoriesGrid & JSXBase.HTMLAttributes<HTMLStoriesGridElement>;
            "stories-icon": LocalJSX.StoriesIcon & JSXBase.HTMLAttributes<HTMLStoriesIconElement>;
            "stories-input": LocalJSX.StoriesInput & JSXBase.HTMLAttributes<HTMLStoriesInputElement>;
            "stories-label": LocalJSX.StoriesLabel & JSXBase.HTMLAttributes<HTMLStoriesLabelElement>;
            "stories-preview": LocalJSX.StoriesPreview & JSXBase.HTMLAttributes<HTMLStoriesPreviewElement>;
            "stories-router": LocalJSX.StoriesRouter & JSXBase.HTMLAttributes<HTMLStoriesRouterElement>;
            "stories-row": LocalJSX.StoriesRow & JSXBase.HTMLAttributes<HTMLStoriesRowElement>;
            "stories-searchbar": LocalJSX.StoriesSearchbar & JSXBase.HTMLAttributes<HTMLStoriesSearchbarElement>;
            "stories-sidebar": LocalJSX.StoriesSidebar & JSXBase.HTMLAttributes<HTMLStoriesSidebarElement>;
            "stories-split-pane": LocalJSX.StoriesSplitPane & JSXBase.HTMLAttributes<HTMLStoriesSplitPaneElement>;
            "stories-tab": LocalJSX.StoriesTab & JSXBase.HTMLAttributes<HTMLStoriesTabElement>;
            "stories-tab-bar": LocalJSX.StoriesTabBar & JSXBase.HTMLAttributes<HTMLStoriesTabBarElement>;
            "stories-tab-button": LocalJSX.StoriesTabButton & JSXBase.HTMLAttributes<HTMLStoriesTabButtonElement>;
            "stories-tabs": LocalJSX.StoriesTabs & JSXBase.HTMLAttributes<HTMLStoriesTabsElement>;
            "stories-tool-bar": LocalJSX.StoriesToolBar & JSXBase.HTMLAttributes<HTMLStoriesToolBarElement>;
            "stories-tool-button": LocalJSX.StoriesToolButton & JSXBase.HTMLAttributes<HTMLStoriesToolButtonElement>;
            "stories-tool-zoom": LocalJSX.StoriesToolZoom & JSXBase.HTMLAttributes<HTMLStoriesToolZoomElement>;
            "stories-zoom": LocalJSX.StoriesZoom & JSXBase.HTMLAttributes<HTMLStoriesZoomElement>;
        }
    }
}
