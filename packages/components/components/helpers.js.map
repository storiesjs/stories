{"file":"helpers.js","mappings":"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","names":[],"sources":["./src/helpers.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `stories-input` should inherit\n * the `title` attribute that developers set directly on `stories-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\n\nimport type { EventEmitter } from \"@stencil/core\";\n\ndeclare const __zone_symbol__requestAnimationFrame: any;\ndeclare const requestAnimationFrame: any;\n\n\nexport const inheritAttributes = (el: HTMLElement, attributes: string[] = []): Record<string, any> => {\n  const attributeObject: Record<string, any> = {};\n\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n\n  return attributeObject;\n}\n\nexport const hasShadowDom = (el: HTMLElement): boolean => {\n\n  return !!el.shadowRoot && !!(el as any).attachShadow;\n};\n\nexport const findItemLabel = (componentEl: HTMLElement): HTMLStoriesLabelElement | null => {\n  const itemEl = componentEl.closest('stories-item');\n  if (itemEl) {\n    return itemEl.querySelector('stories-label');\n  }\n  return null;\n};\n\nexport const deferEvent = (event: EventEmitter): EventEmitter => {\n  return debounceEvent(event, 0);\n};\n\nexport const debounceEvent = (event: EventEmitter, wait: number): EventEmitter => {\n  const original = (event as any)._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  } as EventEmitter;\n};\n\n\nexport const debounce = (func: (...args: any[]) => void, wait = 0): any => {\n  let timer: any;\n  return (...args: any[]): any => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n\n/**\n * This method is used for input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\nexport const getAriaLabel = (componentEl: HTMLElement, inputId: string): { label: Element | null, labelId: string, labelText: string | null | undefined } => {\n  let labelText;\n\n  // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an stories-label\n  const labelledBy = componentEl.getAttribute('aria-labelledby');\n\n  // Grab the id off of the component in case they are using\n  // a custom label using the label element\n  const componentId = componentEl.id;\n\n  let labelId = labelledBy !== null && labelledBy.trim() !== ''\n    ? labelledBy\n    : inputId + '-lbl';\n\n  let label = labelledBy !== null && labelledBy.trim() !== ''\n    ? document.getElementById(labelledBy)\n    : findItemLabel(componentEl);\n\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true');\n\n  // if there is no label, check to see if the user has provided\n  // one by setting an id on the component and using the label element\n  } else if (componentId.trim() !== '') {\n    label = document.querySelector(`label[for=\"${componentId}\"]`);\n\n    if (label) {\n      if (label.id !== '') {\n        labelId = label.id;\n      } else {\n        label.id = labelId = `${componentId}-lbl`;\n      }\n\n      labelText = label.textContent;\n    }\n  }\n\n  return { label, labelId, labelText };\n};\n\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\nexport const renderHiddenInput = (always: boolean, container: HTMLElement, name: string, value: string | undefined | null, disabled: boolean): void => {\n  if (always || hasShadowDom(container)) {\n    let input = container.querySelector('input.aux-input') as HTMLInputElement | null;\n    if (!input) {\n      input = container.ownerDocument!.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\n\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const raf = (h: any) => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\n"],"version":3}