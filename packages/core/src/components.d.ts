/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { Addon, Color, Commands, SearchbarChangeEventDetail, StoryComponent, StoryContext, StoryModules, StyleEventDetail, TabBarChangedEventDetail, TabButtonClickEventDetail, TabButtonLayout, TextFieldTypes, ToolEvent } from "./types";
import { AppState } from "./store";
import { AutocompleteTypes } from "./interface";
export namespace Components {
    interface StoriesAddonActions {
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
    }
    interface StoriesAddonControls {
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
    }
    interface StoriesAddons {
        "findAddon": (id: string) => Promise<Addon>;
        "registerAddon": (addon: Addon) => Promise<void>;
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
        "unregisterAddon": (addon: Addon) => Promise<void>;
    }
    interface StoriesApp {
        /**
          * Story Modules
         */
        "modules": StoryModules;
        /**
          * Story Modules
         */
        "store": AppState;
    }
    interface StoriesBadge {
        /**
          * The badge's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The badge's type.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StoriesButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret": boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle": boolean;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled": boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to.
         */
        "href": string | undefined;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading": boolean;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill": boolean;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel": string | undefined;
        /**
          * Removes focus from the button.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the button.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The button's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Specifies where to display the linked URL. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target": string | undefined;
        /**
          * The type of the button.
         */
        "type": 'submit' | 'reset' | 'button';
        /**
          * The different variants. The options are: `"default"`, `"primary"`, `"secondary"`, `"danger"`, and `"plain"`.
         */
        "variant"?: 'default' | 'primary' | 'secondary' | 'danger' | 'plain';
    }
    interface StoriesCheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled": boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid": boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Removes focus from the checkbox.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the checkbox.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The checkbox's value attribute.
         */
        "value": string;
    }
    interface StoriesCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StoriesDropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect": boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement": HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance": number;
        /**
          * Sets focus on the trigger.
         */
        "focusOnTrigger": () => Promise<void>;
        /**
          * Hides the dropdown panel
         */
        "hide": () => Promise<void>;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist": boolean;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * Shows the dropdown panel
         */
        "show": () => Promise<void>;
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding": number;
    }
    interface StoriesFooter {
    }
    interface StoriesGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed": boolean;
    }
    interface StoriesGroup {
        /**
          * Render the fields horizontal instead of vertical
         */
        "horizontal": boolean;
        /**
          * The field group label. Recommended for proper accessibility. Alternatively, you can use the label slot.
         */
        "label": string;
    }
    interface StoriesIcon {
        /**
          * Icon name
         */
        "name": string;
    }
    interface StoriesInput {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete": AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `stroies-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * Set to true to disable the input control.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "helpText": string;
        /**
          * The input's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid": boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The inputs's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength": number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * The input's name.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * Removes focus from the input.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword": boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface StoriesLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StoriesMenu {
        /**
          * Initiates type-to-select logic, which automatically selects an option based on what the user is currently typing. The key passed will be appended to the internal query and the selection will be updated. After a brief period, the internal query is cleared automatically. This method is intended to be used with the keydown event. Useful for enabling type-to-select when the menu doesn't have focus.
         */
        "typeToSelect": (key: string) => Promise<void>;
    }
    interface StoriesMenuDivider {
    }
    interface StoriesMenuItem {
        /**
          * Set to true to draw the item in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to draw the menu item in a disabled state.
         */
        "disabled": boolean;
        /**
          * Removes focus from the menu item.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the menu item.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * A unique value to store in the menu item. This can be used as a way to identify menu items when selected.
         */
        "value": string;
    }
    interface StoriesMenuLabel {
    }
    interface StoriesPreview {
    }
    interface StoriesRadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled": boolean;
        /**
          * Removes focus from the radio.
         */
        "removeFocus": () => Promise<void>;
        "setButtonTabindex": (value: number) => Promise<void>;
        /**
          * Sets focus on the radio.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The radio's value attribute.
         */
        "value": string;
    }
    interface StoriesRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection": boolean;
        /**
          * Render the radios horizontal instead of vertical
         */
        "horizontal": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid": boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The radio group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface StoriesRouter {
    }
    interface StoriesRow {
    }
    interface StoriesSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon": string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder": string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets focus on the specified `stories-searchbar`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton": 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton": 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type": 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StoriesSelect {
        /**
          * Set to true to add a clear button when the select is populated.
         */
        "clearable": boolean;
        /**
          * Set to true to disable the select control.
         */
        "disabled": boolean;
        /**
          * The select's help text. Alternatively, you can use the help-text slot.
         */
        "helpText": string;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid": boolean;
        /**
          * The select's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The select's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The maximum number of tags to show when `multiple` is true. After the maximum, "+n" will be shown to indicate the number of additional items that are selected. Set to -1 to remove the limit.
         */
        "maxTagsVisible": number;
        /**
          * Set to true to enable multiselect.
         */
        "multiple": boolean;
        /**
          * The select's name.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style select with rounded edges.
         */
        "pill": boolean;
        /**
          * The select's placeholder text.
         */
        "placeholder": string;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * Sets focus on the select.
         */
        "setFocus": () => Promise<void>;
        /**
          * The select's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The value of the control. This will be a string or an array depending on `multiple`.
         */
        "value": string | Array<string>;
    }
    interface StoriesSidebar {
    }
    interface StoriesSpinner {
    }
    interface StoriesSplitPane {
        "defaultSize": number;
        "isResizing": boolean;
        "minSize": number;
        "split": "horizontal" | "vertical";
    }
    interface StoriesTab {
        "active": boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StoriesTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StoriesTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled": boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * The selected tab component
         */
        "selected": boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StoriesTabs {
        /**
          * Get the currently selected tab.
         */
        "getSelected": () => Promise<string | undefined>;
        /**
          * Get a specific tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "getTab": (tab: string | HTMLStoriesTabElement) => Promise<HTMLStoriesTabElement | undefined>;
        /**
          * Select a tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "select": (tab: string | HTMLStoriesTabElement) => Promise<boolean>;
    }
    interface StoriesTag {
        /**
          * Set to true to make the tag clearable.
         */
        "clearable": boolean;
        /**
          * Set to true to draw a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StoriesTextarea {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `stories-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * Set to true to disable the textarea.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "helpText": string;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid": boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label": string | undefined;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength": number;
        /**
          * The textarea's name attribute.
         */
        "name": string;
        /**
          * The textarea's placeholder text.
         */
        "placeholder": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * Removes focus fromt the textarea.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize": 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows": number;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets focus on the textarea.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The textarea's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * The textarea's value attribute.
         */
        "value": string;
    }
    interface StoriesToolBar {
    }
    interface StoriesToolButton {
        /**
          * command property
         */
        "command": Commands;
        /**
          * disabled property
         */
        "disabled": boolean;
        /**
          * icon property
         */
        "icon": string;
    }
    interface StoriesToolZoom {
    }
    interface StoriesZoom {
        "zoom": number;
    }
}
declare global {
    interface HTMLStoriesAddonActionsElement extends Components.StoriesAddonActions, HTMLStencilElement {
    }
    var HTMLStoriesAddonActionsElement: {
        prototype: HTMLStoriesAddonActionsElement;
        new (): HTMLStoriesAddonActionsElement;
    };
    interface HTMLStoriesAddonControlsElement extends Components.StoriesAddonControls, HTMLStencilElement {
    }
    var HTMLStoriesAddonControlsElement: {
        prototype: HTMLStoriesAddonControlsElement;
        new (): HTMLStoriesAddonControlsElement;
    };
    interface HTMLStoriesAddonsElement extends Components.StoriesAddons, HTMLStencilElement {
    }
    var HTMLStoriesAddonsElement: {
        prototype: HTMLStoriesAddonsElement;
        new (): HTMLStoriesAddonsElement;
    };
    interface HTMLStoriesAppElement extends Components.StoriesApp, HTMLStencilElement {
    }
    var HTMLStoriesAppElement: {
        prototype: HTMLStoriesAppElement;
        new (): HTMLStoriesAppElement;
    };
    interface HTMLStoriesBadgeElement extends Components.StoriesBadge, HTMLStencilElement {
    }
    var HTMLStoriesBadgeElement: {
        prototype: HTMLStoriesBadgeElement;
        new (): HTMLStoriesBadgeElement;
    };
    interface HTMLStoriesButtonElement extends Components.StoriesButton, HTMLStencilElement {
    }
    var HTMLStoriesButtonElement: {
        prototype: HTMLStoriesButtonElement;
        new (): HTMLStoriesButtonElement;
    };
    interface HTMLStoriesCheckboxElement extends Components.StoriesCheckbox, HTMLStencilElement {
    }
    var HTMLStoriesCheckboxElement: {
        prototype: HTMLStoriesCheckboxElement;
        new (): HTMLStoriesCheckboxElement;
    };
    interface HTMLStoriesColElement extends Components.StoriesCol, HTMLStencilElement {
    }
    var HTMLStoriesColElement: {
        prototype: HTMLStoriesColElement;
        new (): HTMLStoriesColElement;
    };
    interface HTMLStoriesDropdownElement extends Components.StoriesDropdown, HTMLStencilElement {
    }
    var HTMLStoriesDropdownElement: {
        prototype: HTMLStoriesDropdownElement;
        new (): HTMLStoriesDropdownElement;
    };
    interface HTMLStoriesFooterElement extends Components.StoriesFooter, HTMLStencilElement {
    }
    var HTMLStoriesFooterElement: {
        prototype: HTMLStoriesFooterElement;
        new (): HTMLStoriesFooterElement;
    };
    interface HTMLStoriesGridElement extends Components.StoriesGrid, HTMLStencilElement {
    }
    var HTMLStoriesGridElement: {
        prototype: HTMLStoriesGridElement;
        new (): HTMLStoriesGridElement;
    };
    interface HTMLStoriesGroupElement extends Components.StoriesGroup, HTMLStencilElement {
    }
    var HTMLStoriesGroupElement: {
        prototype: HTMLStoriesGroupElement;
        new (): HTMLStoriesGroupElement;
    };
    interface HTMLStoriesIconElement extends Components.StoriesIcon, HTMLStencilElement {
    }
    var HTMLStoriesIconElement: {
        prototype: HTMLStoriesIconElement;
        new (): HTMLStoriesIconElement;
    };
    interface HTMLStoriesInputElement extends Components.StoriesInput, HTMLStencilElement {
    }
    var HTMLStoriesInputElement: {
        prototype: HTMLStoriesInputElement;
        new (): HTMLStoriesInputElement;
    };
    interface HTMLStoriesLabelElement extends Components.StoriesLabel, HTMLStencilElement {
    }
    var HTMLStoriesLabelElement: {
        prototype: HTMLStoriesLabelElement;
        new (): HTMLStoriesLabelElement;
    };
    interface HTMLStoriesMenuElement extends Components.StoriesMenu, HTMLStencilElement {
    }
    var HTMLStoriesMenuElement: {
        prototype: HTMLStoriesMenuElement;
        new (): HTMLStoriesMenuElement;
    };
    interface HTMLStoriesMenuDividerElement extends Components.StoriesMenuDivider, HTMLStencilElement {
    }
    var HTMLStoriesMenuDividerElement: {
        prototype: HTMLStoriesMenuDividerElement;
        new (): HTMLStoriesMenuDividerElement;
    };
    interface HTMLStoriesMenuItemElement extends Components.StoriesMenuItem, HTMLStencilElement {
    }
    var HTMLStoriesMenuItemElement: {
        prototype: HTMLStoriesMenuItemElement;
        new (): HTMLStoriesMenuItemElement;
    };
    interface HTMLStoriesMenuLabelElement extends Components.StoriesMenuLabel, HTMLStencilElement {
    }
    var HTMLStoriesMenuLabelElement: {
        prototype: HTMLStoriesMenuLabelElement;
        new (): HTMLStoriesMenuLabelElement;
    };
    interface HTMLStoriesPreviewElement extends Components.StoriesPreview, HTMLStencilElement {
    }
    var HTMLStoriesPreviewElement: {
        prototype: HTMLStoriesPreviewElement;
        new (): HTMLStoriesPreviewElement;
    };
    interface HTMLStoriesRadioElement extends Components.StoriesRadio, HTMLStencilElement {
    }
    var HTMLStoriesRadioElement: {
        prototype: HTMLStoriesRadioElement;
        new (): HTMLStoriesRadioElement;
    };
    interface HTMLStoriesRadioGroupElement extends Components.StoriesRadioGroup, HTMLStencilElement {
    }
    var HTMLStoriesRadioGroupElement: {
        prototype: HTMLStoriesRadioGroupElement;
        new (): HTMLStoriesRadioGroupElement;
    };
    interface HTMLStoriesRouterElement extends Components.StoriesRouter, HTMLStencilElement {
    }
    var HTMLStoriesRouterElement: {
        prototype: HTMLStoriesRouterElement;
        new (): HTMLStoriesRouterElement;
    };
    interface HTMLStoriesRowElement extends Components.StoriesRow, HTMLStencilElement {
    }
    var HTMLStoriesRowElement: {
        prototype: HTMLStoriesRowElement;
        new (): HTMLStoriesRowElement;
    };
    interface HTMLStoriesSearchbarElement extends Components.StoriesSearchbar, HTMLStencilElement {
    }
    var HTMLStoriesSearchbarElement: {
        prototype: HTMLStoriesSearchbarElement;
        new (): HTMLStoriesSearchbarElement;
    };
    interface HTMLStoriesSelectElement extends Components.StoriesSelect, HTMLStencilElement {
    }
    var HTMLStoriesSelectElement: {
        prototype: HTMLStoriesSelectElement;
        new (): HTMLStoriesSelectElement;
    };
    interface HTMLStoriesSidebarElement extends Components.StoriesSidebar, HTMLStencilElement {
    }
    var HTMLStoriesSidebarElement: {
        prototype: HTMLStoriesSidebarElement;
        new (): HTMLStoriesSidebarElement;
    };
    interface HTMLStoriesSpinnerElement extends Components.StoriesSpinner, HTMLStencilElement {
    }
    var HTMLStoriesSpinnerElement: {
        prototype: HTMLStoriesSpinnerElement;
        new (): HTMLStoriesSpinnerElement;
    };
    interface HTMLStoriesSplitPaneElement extends Components.StoriesSplitPane, HTMLStencilElement {
    }
    var HTMLStoriesSplitPaneElement: {
        prototype: HTMLStoriesSplitPaneElement;
        new (): HTMLStoriesSplitPaneElement;
    };
    interface HTMLStoriesTabElement extends Components.StoriesTab, HTMLStencilElement {
    }
    var HTMLStoriesTabElement: {
        prototype: HTMLStoriesTabElement;
        new (): HTMLStoriesTabElement;
    };
    interface HTMLStoriesTabBarElement extends Components.StoriesTabBar, HTMLStencilElement {
    }
    var HTMLStoriesTabBarElement: {
        prototype: HTMLStoriesTabBarElement;
        new (): HTMLStoriesTabBarElement;
    };
    interface HTMLStoriesTabButtonElement extends Components.StoriesTabButton, HTMLStencilElement {
    }
    var HTMLStoriesTabButtonElement: {
        prototype: HTMLStoriesTabButtonElement;
        new (): HTMLStoriesTabButtonElement;
    };
    interface HTMLStoriesTabsElement extends Components.StoriesTabs, HTMLStencilElement {
    }
    var HTMLStoriesTabsElement: {
        prototype: HTMLStoriesTabsElement;
        new (): HTMLStoriesTabsElement;
    };
    interface HTMLStoriesTagElement extends Components.StoriesTag, HTMLStencilElement {
    }
    var HTMLStoriesTagElement: {
        prototype: HTMLStoriesTagElement;
        new (): HTMLStoriesTagElement;
    };
    interface HTMLStoriesTextareaElement extends Components.StoriesTextarea, HTMLStencilElement {
    }
    var HTMLStoriesTextareaElement: {
        prototype: HTMLStoriesTextareaElement;
        new (): HTMLStoriesTextareaElement;
    };
    interface HTMLStoriesToolBarElement extends Components.StoriesToolBar, HTMLStencilElement {
    }
    var HTMLStoriesToolBarElement: {
        prototype: HTMLStoriesToolBarElement;
        new (): HTMLStoriesToolBarElement;
    };
    interface HTMLStoriesToolButtonElement extends Components.StoriesToolButton, HTMLStencilElement {
    }
    var HTMLStoriesToolButtonElement: {
        prototype: HTMLStoriesToolButtonElement;
        new (): HTMLStoriesToolButtonElement;
    };
    interface HTMLStoriesToolZoomElement extends Components.StoriesToolZoom, HTMLStencilElement {
    }
    var HTMLStoriesToolZoomElement: {
        prototype: HTMLStoriesToolZoomElement;
        new (): HTMLStoriesToolZoomElement;
    };
    interface HTMLStoriesZoomElement extends Components.StoriesZoom, HTMLStencilElement {
    }
    var HTMLStoriesZoomElement: {
        prototype: HTMLStoriesZoomElement;
        new (): HTMLStoriesZoomElement;
    };
    interface HTMLElementTagNameMap {
        "stories-addon-actions": HTMLStoriesAddonActionsElement;
        "stories-addon-controls": HTMLStoriesAddonControlsElement;
        "stories-addons": HTMLStoriesAddonsElement;
        "stories-app": HTMLStoriesAppElement;
        "stories-badge": HTMLStoriesBadgeElement;
        "stories-button": HTMLStoriesButtonElement;
        "stories-checkbox": HTMLStoriesCheckboxElement;
        "stories-col": HTMLStoriesColElement;
        "stories-dropdown": HTMLStoriesDropdownElement;
        "stories-footer": HTMLStoriesFooterElement;
        "stories-grid": HTMLStoriesGridElement;
        "stories-group": HTMLStoriesGroupElement;
        "stories-icon": HTMLStoriesIconElement;
        "stories-input": HTMLStoriesInputElement;
        "stories-label": HTMLStoriesLabelElement;
        "stories-menu": HTMLStoriesMenuElement;
        "stories-menu-divider": HTMLStoriesMenuDividerElement;
        "stories-menu-item": HTMLStoriesMenuItemElement;
        "stories-menu-label": HTMLStoriesMenuLabelElement;
        "stories-preview": HTMLStoriesPreviewElement;
        "stories-radio": HTMLStoriesRadioElement;
        "stories-radio-group": HTMLStoriesRadioGroupElement;
        "stories-router": HTMLStoriesRouterElement;
        "stories-row": HTMLStoriesRowElement;
        "stories-searchbar": HTMLStoriesSearchbarElement;
        "stories-select": HTMLStoriesSelectElement;
        "stories-sidebar": HTMLStoriesSidebarElement;
        "stories-spinner": HTMLStoriesSpinnerElement;
        "stories-split-pane": HTMLStoriesSplitPaneElement;
        "stories-tab": HTMLStoriesTabElement;
        "stories-tab-bar": HTMLStoriesTabBarElement;
        "stories-tab-button": HTMLStoriesTabButtonElement;
        "stories-tabs": HTMLStoriesTabsElement;
        "stories-tag": HTMLStoriesTagElement;
        "stories-textarea": HTMLStoriesTextareaElement;
        "stories-tool-bar": HTMLStoriesToolBarElement;
        "stories-tool-button": HTMLStoriesToolButtonElement;
        "stories-tool-zoom": HTMLStoriesToolZoomElement;
        "stories-zoom": HTMLStoriesZoomElement;
    }
}
declare namespace LocalJSX {
    interface StoriesAddonActions {
    }
    interface StoriesAddonControls {
    }
    interface StoriesAddons {
    }
    interface StoriesApp {
        /**
          * Story Modules
         */
        "modules"?: StoryModules;
        "onStoryChange"?: (event: CustomEvent<StoryComponent>) => void;
        "onStoryContextChange"?: (event: CustomEvent<StoryContext>) => void;
        /**
          * Story Modules
         */
        "store"?: AppState;
    }
    interface StoriesBadge {
        /**
          * The badge's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The badge's type.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StoriesButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret"?: boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle"?: boolean;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled"?: boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to.
         */
        "href"?: string | undefined;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading"?: boolean;
        /**
          * Emitted when the button loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the button has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill"?: boolean;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel"?: string | undefined;
        /**
          * The button's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Specifies where to display the linked URL. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target"?: string | undefined;
        /**
          * The type of the button.
         */
        "type"?: 'submit' | 'reset' | 'button';
        /**
          * The different variants. The options are: `"default"`, `"primary"`, `"secondary"`, `"danger"`, and `"plain"`.
         */
        "variant"?: 'default' | 'primary' | 'secondary' | 'danger' | 'plain';
    }
    interface StoriesCheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled"?: boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid"?: boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onStoriesChange"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * The checkbox's value attribute.
         */
        "value"?: string;
    }
    interface StoriesCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StoriesDropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect"?: boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement"?: HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance"?: number;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist"?: boolean;
        /**
          * Emitted after the dropdown closes and all transitions are complete.
         */
        "onStoriesAfterHide"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted after the dropdown opens and all transitions are complete.
         */
        "onStoriesAfterShow"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the dropdown closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onStoriesHide"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onStoriesShow"?: (event: CustomEvent<void>) => void;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding"?: number;
    }
    interface StoriesFooter {
    }
    interface StoriesGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed"?: boolean;
    }
    interface StoriesGroup {
        /**
          * Render the fields horizontal instead of vertical
         */
        "horizontal"?: boolean;
        /**
          * The field group label. Recommended for proper accessibility. Alternatively, you can use the label slot.
         */
        "label"?: string;
    }
    interface StoriesIcon {
        /**
          * Icon name
         */
        "name"?: string;
    }
    interface StoriesInput {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete"?: AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `stroies-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * Set to true to disable the input control.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "helpText"?: string;
        /**
          * The input's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid"?: boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The inputs's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * The input's name.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onStroiesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onStroiesChange"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onStroiesClear"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStroiesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onStroiesInput"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword"?: boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface StoriesLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StoriesMenu {
        /**
          * Emitted when a menu item is selected.
         */
        "onStoriesSelect"?: (event: CustomEvent<{ item: HTMLStoriesMenuItemElement }>) => void;
    }
    interface StoriesMenuDivider {
    }
    interface StoriesMenuItem {
        /**
          * Set to true to draw the item in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to draw the menu item in a disabled state.
         */
        "disabled"?: boolean;
        /**
          * A unique value to store in the menu item. This can be used as a way to identify menu items when selected.
         */
        "value"?: string;
    }
    interface StoriesMenuLabel {
    }
    interface StoriesPreview {
    }
    interface StoriesRadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled"?: boolean;
        /**
          * Emitted when the control loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<any>) => void;
        /**
          * The radio's value attribute.
         */
        "value"?: string;
    }
    interface StoriesRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection"?: boolean;
        /**
          * Render the radios horizontal instead of vertical
         */
        "horizontal"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid"?: boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The radio group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the value has changed.
         */
        "onStoriesChange"?: (event: CustomEvent<any>) => void;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface StoriesRouter {
    }
    interface StoriesRow {
    }
    interface StoriesSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon"?: string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Emitted when the input loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the cancel button is clicked.
         */
        "onStoriesCancel"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onStoriesChange"?: (event: CustomEvent<SearchbarChangeEventDetail>) => void;
        /**
          * Emitted when the clear input button is clicked.
         */
        "onStoriesClear"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onStoriesInput"?: (event: CustomEvent<KeyboardEvent>) => void;
        /**
          * Emitted when the styles change.
         */
        "onStoriesStyle"?: (event: CustomEvent<StyleEventDetail>) => void;
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder"?: string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton"?: 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton"?: 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type"?: 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StoriesSelect {
        /**
          * Set to true to add a clear button when the select is populated.
         */
        "clearable"?: boolean;
        /**
          * Set to true to disable the select control.
         */
        "disabled"?: boolean;
        /**
          * The select's help text. Alternatively, you can use the help-text slot.
         */
        "helpText"?: string;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid"?: boolean;
        /**
          * The select's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The select's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The maximum number of tags to show when `multiple` is true. After the maximum, "+n" will be shown to indicate the number of additional items that are selected. Set to -1 to remove the limit.
         */
        "maxTagsVisible"?: number;
        /**
          * Set to true to enable multiselect.
         */
        "multiple"?: boolean;
        /**
          * The select's name.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onStoriesChange"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style select with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The select's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * The select's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The value of the control. This will be a string or an array depending on `multiple`.
         */
        "value"?: string | Array<string>;
    }
    interface StoriesSidebar {
    }
    interface StoriesSpinner {
    }
    interface StoriesSplitPane {
        "defaultSize"?: number;
        "isResizing"?: boolean;
        "minSize"?: number;
        "onStoriesSizeChange"?: (event: CustomEvent<number>) => void;
        "split"?: "horizontal" | "vertical";
    }
    interface StoriesTab {
        "active"?: boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StoriesTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        "onStoriesTabBarChange"?: (event: CustomEvent<TabBarChangedEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StoriesTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled"?: boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * Emitted when the tab bar is clicked
         */
        "onStoriesTabButtonClick"?: (event: CustomEvent<TabButtonClickEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selected"?: boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StoriesTabs {
    }
    interface StoriesTag {
        /**
          * Set to true to make the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Emitted when the clear button is activated.
         */
        "onStoriesClear"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StoriesTextarea {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `stories-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * Set to true to disable the textarea.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "helpText"?: string;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid"?: boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label"?: string | undefined;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength"?: number;
        /**
          * The textarea's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the textarea loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the textarea's value changes.
         */
        "onStoriesChange"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the textarea has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the textarea receives input.
         */
        "onStoriesInput"?: (event: CustomEvent<void>) => void;
        /**
          * The textarea's placeholder text.
         */
        "placeholder"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize"?: 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows"?: number;
        /**
          * The textarea's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * The textarea's value attribute.
         */
        "value"?: string;
    }
    interface StoriesToolBar {
    }
    interface StoriesToolButton {
        /**
          * command property
         */
        "command"?: Commands;
        /**
          * disabled property
         */
        "disabled"?: boolean;
        /**
          * icon property
         */
        "icon"?: string;
        /**
          * Action Event
         */
        "onStoriesAction"?: (event: CustomEvent<ToolEvent>) => void;
    }
    interface StoriesToolZoom {
    }
    interface StoriesZoom {
        "zoom"?: number;
    }
    interface IntrinsicElements {
        "stories-addon-actions": StoriesAddonActions;
        "stories-addon-controls": StoriesAddonControls;
        "stories-addons": StoriesAddons;
        "stories-app": StoriesApp;
        "stories-badge": StoriesBadge;
        "stories-button": StoriesButton;
        "stories-checkbox": StoriesCheckbox;
        "stories-col": StoriesCol;
        "stories-dropdown": StoriesDropdown;
        "stories-footer": StoriesFooter;
        "stories-grid": StoriesGrid;
        "stories-group": StoriesGroup;
        "stories-icon": StoriesIcon;
        "stories-input": StoriesInput;
        "stories-label": StoriesLabel;
        "stories-menu": StoriesMenu;
        "stories-menu-divider": StoriesMenuDivider;
        "stories-menu-item": StoriesMenuItem;
        "stories-menu-label": StoriesMenuLabel;
        "stories-preview": StoriesPreview;
        "stories-radio": StoriesRadio;
        "stories-radio-group": StoriesRadioGroup;
        "stories-router": StoriesRouter;
        "stories-row": StoriesRow;
        "stories-searchbar": StoriesSearchbar;
        "stories-select": StoriesSelect;
        "stories-sidebar": StoriesSidebar;
        "stories-spinner": StoriesSpinner;
        "stories-split-pane": StoriesSplitPane;
        "stories-tab": StoriesTab;
        "stories-tab-bar": StoriesTabBar;
        "stories-tab-button": StoriesTabButton;
        "stories-tabs": StoriesTabs;
        "stories-tag": StoriesTag;
        "stories-textarea": StoriesTextarea;
        "stories-tool-bar": StoriesToolBar;
        "stories-tool-button": StoriesToolButton;
        "stories-tool-zoom": StoriesToolZoom;
        "stories-zoom": StoriesZoom;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "stories-addon-actions": LocalJSX.StoriesAddonActions & JSXBase.HTMLAttributes<HTMLStoriesAddonActionsElement>;
            "stories-addon-controls": LocalJSX.StoriesAddonControls & JSXBase.HTMLAttributes<HTMLStoriesAddonControlsElement>;
            "stories-addons": LocalJSX.StoriesAddons & JSXBase.HTMLAttributes<HTMLStoriesAddonsElement>;
            "stories-app": LocalJSX.StoriesApp & JSXBase.HTMLAttributes<HTMLStoriesAppElement>;
            "stories-badge": LocalJSX.StoriesBadge & JSXBase.HTMLAttributes<HTMLStoriesBadgeElement>;
            "stories-button": LocalJSX.StoriesButton & JSXBase.HTMLAttributes<HTMLStoriesButtonElement>;
            "stories-checkbox": LocalJSX.StoriesCheckbox & JSXBase.HTMLAttributes<HTMLStoriesCheckboxElement>;
            "stories-col": LocalJSX.StoriesCol & JSXBase.HTMLAttributes<HTMLStoriesColElement>;
            "stories-dropdown": LocalJSX.StoriesDropdown & JSXBase.HTMLAttributes<HTMLStoriesDropdownElement>;
            "stories-footer": LocalJSX.StoriesFooter & JSXBase.HTMLAttributes<HTMLStoriesFooterElement>;
            "stories-grid": LocalJSX.StoriesGrid & JSXBase.HTMLAttributes<HTMLStoriesGridElement>;
            "stories-group": LocalJSX.StoriesGroup & JSXBase.HTMLAttributes<HTMLStoriesGroupElement>;
            "stories-icon": LocalJSX.StoriesIcon & JSXBase.HTMLAttributes<HTMLStoriesIconElement>;
            "stories-input": LocalJSX.StoriesInput & JSXBase.HTMLAttributes<HTMLStoriesInputElement>;
            "stories-label": LocalJSX.StoriesLabel & JSXBase.HTMLAttributes<HTMLStoriesLabelElement>;
            "stories-menu": LocalJSX.StoriesMenu & JSXBase.HTMLAttributes<HTMLStoriesMenuElement>;
            "stories-menu-divider": LocalJSX.StoriesMenuDivider & JSXBase.HTMLAttributes<HTMLStoriesMenuDividerElement>;
            "stories-menu-item": LocalJSX.StoriesMenuItem & JSXBase.HTMLAttributes<HTMLStoriesMenuItemElement>;
            "stories-menu-label": LocalJSX.StoriesMenuLabel & JSXBase.HTMLAttributes<HTMLStoriesMenuLabelElement>;
            "stories-preview": LocalJSX.StoriesPreview & JSXBase.HTMLAttributes<HTMLStoriesPreviewElement>;
            "stories-radio": LocalJSX.StoriesRadio & JSXBase.HTMLAttributes<HTMLStoriesRadioElement>;
            "stories-radio-group": LocalJSX.StoriesRadioGroup & JSXBase.HTMLAttributes<HTMLStoriesRadioGroupElement>;
            "stories-router": LocalJSX.StoriesRouter & JSXBase.HTMLAttributes<HTMLStoriesRouterElement>;
            "stories-row": LocalJSX.StoriesRow & JSXBase.HTMLAttributes<HTMLStoriesRowElement>;
            "stories-searchbar": LocalJSX.StoriesSearchbar & JSXBase.HTMLAttributes<HTMLStoriesSearchbarElement>;
            "stories-select": LocalJSX.StoriesSelect & JSXBase.HTMLAttributes<HTMLStoriesSelectElement>;
            "stories-sidebar": LocalJSX.StoriesSidebar & JSXBase.HTMLAttributes<HTMLStoriesSidebarElement>;
            "stories-spinner": LocalJSX.StoriesSpinner & JSXBase.HTMLAttributes<HTMLStoriesSpinnerElement>;
            "stories-split-pane": LocalJSX.StoriesSplitPane & JSXBase.HTMLAttributes<HTMLStoriesSplitPaneElement>;
            "stories-tab": LocalJSX.StoriesTab & JSXBase.HTMLAttributes<HTMLStoriesTabElement>;
            "stories-tab-bar": LocalJSX.StoriesTabBar & JSXBase.HTMLAttributes<HTMLStoriesTabBarElement>;
            "stories-tab-button": LocalJSX.StoriesTabButton & JSXBase.HTMLAttributes<HTMLStoriesTabButtonElement>;
            "stories-tabs": LocalJSX.StoriesTabs & JSXBase.HTMLAttributes<HTMLStoriesTabsElement>;
            "stories-tag": LocalJSX.StoriesTag & JSXBase.HTMLAttributes<HTMLStoriesTagElement>;
            "stories-textarea": LocalJSX.StoriesTextarea & JSXBase.HTMLAttributes<HTMLStoriesTextareaElement>;
            "stories-tool-bar": LocalJSX.StoriesToolBar & JSXBase.HTMLAttributes<HTMLStoriesToolBarElement>;
            "stories-tool-button": LocalJSX.StoriesToolButton & JSXBase.HTMLAttributes<HTMLStoriesToolButtonElement>;
            "stories-tool-zoom": LocalJSX.StoriesToolZoom & JSXBase.HTMLAttributes<HTMLStoriesToolZoomElement>;
            "stories-zoom": LocalJSX.StoriesZoom & JSXBase.HTMLAttributes<HTMLStoriesZoomElement>;
        }
    }
}
