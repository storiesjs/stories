/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { Addon, Color, Commands, SearchbarChangeEventDetail, StoryComponent, StoryContext, StoryModules, StyleEventDetail, TabBarChangedEventDetail, TabButtonClickEventDetail, TabButtonLayout, TextFieldTypes, ToolEvent } from "./types";
import { AppState } from "./store";
import { AutocompleteTypes } from "./interface";
export namespace Components {
    interface StrAddonActions {
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
    }
    interface StrAddonControls {
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
    }
    interface StrAddons {
        "findAddon": (id: string) => Promise<Addon>;
        "registerAddon": (addon: Addon) => Promise<void>;
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
        "unregisterAddon": (addon: Addon) => Promise<void>;
    }
    interface StrApp {
        /**
          * Story Modules
         */
        "modules": StoryModules;
        /**
          * Story Modules
         */
        "store": AppState;
    }
    interface StrBadge {
        /**
          * The badge's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The badge's type.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StrButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret": boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle": boolean;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled": boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to.
         */
        "href": string | undefined;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading": boolean;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill": boolean;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel": string | undefined;
        /**
          * Removes focus from the button.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the button.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The button's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Specifies where to display the linked URL. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target": string | undefined;
        /**
          * The type of the button.
         */
        "type": 'submit' | 'reset' | 'button';
        /**
          * The different variants. The options are: `"default"`, `"primary"`, `"secondary"`, `"danger"`, and `"plain"`.
         */
        "variant"?: 'default' | 'primary' | 'secondary' | 'danger' | 'plain';
    }
    interface StrCheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled": boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid": boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Removes focus from the checkbox.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the checkbox.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The checkbox's value attribute.
         */
        "value": string;
    }
    interface StrCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StrDropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect": boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement": HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance": number;
        /**
          * Sets focus on the trigger.
         */
        "focusOnTrigger": () => Promise<void>;
        /**
          * Hides the dropdown panel
         */
        "hide": () => Promise<void>;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist": boolean;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * Shows the dropdown panel
         */
        "show": () => Promise<void>;
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding": number;
    }
    interface StrFooter {
    }
    interface StrGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed": boolean;
    }
    interface StrGroup {
        /**
          * Render the fields horizontal instead of vertical
         */
        "horizontal": boolean;
        /**
          * The field group label. Recommended for proper accessibility. Alternatively, you can use the label slot.
         */
        "label": string;
    }
    interface StrIcon {
        /**
          * Icon name
         */
        "name": string;
    }
    interface StrInput {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete": AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `stroies-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * Set to true to disable the input control.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "helpText": string;
        /**
          * The input's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid": boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The inputs's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength": number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * The input's name.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * Removes focus from the input.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword": boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface StrLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StrMenu {
        /**
          * Initiates type-to-select logic, which automatically selects an option based on what the user is currently typing. The key passed will be appended to the internal query and the selection will be updated. After a brief period, the internal query is cleared automatically. This method is intended to be used with the keydown event. Useful for enabling type-to-select when the menu doesn't have focus.
         */
        "typeToSelect": (key: string) => Promise<void>;
    }
    interface StrMenuDivider {
    }
    interface StrMenuItem {
        /**
          * Set to true to draw the item in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to draw the menu item in a disabled state.
         */
        "disabled": boolean;
        /**
          * Removes focus from the menu item.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the menu item.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * A unique value to store in the menu item. This can be used as a way to identify menu items when selected.
         */
        "value": string;
    }
    interface StrMenuLabel {
    }
    interface StrPreview {
    }
    interface StrRadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled": boolean;
        /**
          * Removes focus from the radio.
         */
        "removeFocus": () => Promise<void>;
        "setButtonTabindex": (value: number) => Promise<void>;
        /**
          * Sets focus on the radio.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The radio's value attribute.
         */
        "value": string;
    }
    interface StrRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection": boolean;
        /**
          * Render the radios horizontal instead of vertical
         */
        "horizontal": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid": boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The radio group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface StrRouter {
    }
    interface StrRow {
    }
    interface StrSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon": string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder": string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets focus on the specified `str-searchbar`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton": 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton": 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type": 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StrSelect {
        /**
          * Set to true to add a clear button when the select is populated.
         */
        "clearable": boolean;
        /**
          * Set to true to disable the select control.
         */
        "disabled": boolean;
        /**
          * The select's help text. Alternatively, you can use the help-text slot.
         */
        "helpText": string;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid": boolean;
        /**
          * The select's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The select's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The maximum number of tags to show when `multiple` is true. After the maximum, "+n" will be shown to indicate the number of additional items that are selected. Set to -1 to remove the limit.
         */
        "maxTagsVisible": number;
        /**
          * Set to true to enable multiselect.
         */
        "multiple": boolean;
        /**
          * The select's name.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style select with rounded edges.
         */
        "pill": boolean;
        /**
          * The select's placeholder text.
         */
        "placeholder": string;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * Sets focus on the select.
         */
        "setFocus": () => Promise<void>;
        /**
          * The select's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The value of the control. This will be a string or an array depending on `multiple`.
         */
        "value": string | Array<string>;
    }
    interface StrSidebar {
    }
    interface StrSpinner {
    }
    interface StrSplitPane {
        "defaultSize": number;
        "isResizing": boolean;
        "minSize": number;
        "split": "horizontal" | "vertical";
    }
    interface StrTab {
        "active": boolean;
        /**
          * A tab id must be provided for each `str-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StrTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StrTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled": boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * The selected tab component
         */
        "selected": boolean;
        /**
          * A tab id must be provided for each `str-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StrTabs {
        /**
          * Get the currently selected tab.
         */
        "getSelected": () => Promise<string | undefined>;
        /**
          * Get a specific tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "getTab": (tab: string | HTMLStrTabElement) => Promise<HTMLStrTabElement | undefined>;
        /**
          * Select a tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "select": (tab: string | HTMLStrTabElement) => Promise<boolean>;
    }
    interface StrTag {
        /**
          * Set to true to make the tag clearable.
         */
        "clearable": boolean;
        /**
          * Set to true to draw a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StrTextarea {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `str-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * Set to true to disable the textarea.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "helpText": string;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid": boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label": string | undefined;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength": number;
        /**
          * The textarea's name attribute.
         */
        "name": string;
        /**
          * The textarea's placeholder text.
         */
        "placeholder": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * Removes focus fromt the textarea.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize": 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows": number;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets focus on the textarea.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The textarea's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * The textarea's value attribute.
         */
        "value": string;
    }
    interface StrToolBar {
    }
    interface StrToolButton {
        /**
          * command property
         */
        "command": Commands;
        /**
          * disabled property
         */
        "disabled": boolean;
        /**
          * icon property
         */
        "icon": string;
    }
    interface StrToolZoom {
    }
    interface StrZoom {
        "zoom": number;
    }
}
declare global {
    interface HTMLStrAddonActionsElement extends Components.StrAddonActions, HTMLStencilElement {
    }
    var HTMLStrAddonActionsElement: {
        prototype: HTMLStrAddonActionsElement;
        new (): HTMLStrAddonActionsElement;
    };
    interface HTMLStrAddonControlsElement extends Components.StrAddonControls, HTMLStencilElement {
    }
    var HTMLStrAddonControlsElement: {
        prototype: HTMLStrAddonControlsElement;
        new (): HTMLStrAddonControlsElement;
    };
    interface HTMLStrAddonsElement extends Components.StrAddons, HTMLStencilElement {
    }
    var HTMLStrAddonsElement: {
        prototype: HTMLStrAddonsElement;
        new (): HTMLStrAddonsElement;
    };
    interface HTMLStrAppElement extends Components.StrApp, HTMLStencilElement {
    }
    var HTMLStrAppElement: {
        prototype: HTMLStrAppElement;
        new (): HTMLStrAppElement;
    };
    interface HTMLStrBadgeElement extends Components.StrBadge, HTMLStencilElement {
    }
    var HTMLStrBadgeElement: {
        prototype: HTMLStrBadgeElement;
        new (): HTMLStrBadgeElement;
    };
    interface HTMLStrButtonElement extends Components.StrButton, HTMLStencilElement {
    }
    var HTMLStrButtonElement: {
        prototype: HTMLStrButtonElement;
        new (): HTMLStrButtonElement;
    };
    interface HTMLStrCheckboxElement extends Components.StrCheckbox, HTMLStencilElement {
    }
    var HTMLStrCheckboxElement: {
        prototype: HTMLStrCheckboxElement;
        new (): HTMLStrCheckboxElement;
    };
    interface HTMLStrColElement extends Components.StrCol, HTMLStencilElement {
    }
    var HTMLStrColElement: {
        prototype: HTMLStrColElement;
        new (): HTMLStrColElement;
    };
    interface HTMLStrDropdownElement extends Components.StrDropdown, HTMLStencilElement {
    }
    var HTMLStrDropdownElement: {
        prototype: HTMLStrDropdownElement;
        new (): HTMLStrDropdownElement;
    };
    interface HTMLStrFooterElement extends Components.StrFooter, HTMLStencilElement {
    }
    var HTMLStrFooterElement: {
        prototype: HTMLStrFooterElement;
        new (): HTMLStrFooterElement;
    };
    interface HTMLStrGridElement extends Components.StrGrid, HTMLStencilElement {
    }
    var HTMLStrGridElement: {
        prototype: HTMLStrGridElement;
        new (): HTMLStrGridElement;
    };
    interface HTMLStrGroupElement extends Components.StrGroup, HTMLStencilElement {
    }
    var HTMLStrGroupElement: {
        prototype: HTMLStrGroupElement;
        new (): HTMLStrGroupElement;
    };
    interface HTMLStrIconElement extends Components.StrIcon, HTMLStencilElement {
    }
    var HTMLStrIconElement: {
        prototype: HTMLStrIconElement;
        new (): HTMLStrIconElement;
    };
    interface HTMLStrInputElement extends Components.StrInput, HTMLStencilElement {
    }
    var HTMLStrInputElement: {
        prototype: HTMLStrInputElement;
        new (): HTMLStrInputElement;
    };
    interface HTMLStrLabelElement extends Components.StrLabel, HTMLStencilElement {
    }
    var HTMLStrLabelElement: {
        prototype: HTMLStrLabelElement;
        new (): HTMLStrLabelElement;
    };
    interface HTMLStrMenuElement extends Components.StrMenu, HTMLStencilElement {
    }
    var HTMLStrMenuElement: {
        prototype: HTMLStrMenuElement;
        new (): HTMLStrMenuElement;
    };
    interface HTMLStrMenuDividerElement extends Components.StrMenuDivider, HTMLStencilElement {
    }
    var HTMLStrMenuDividerElement: {
        prototype: HTMLStrMenuDividerElement;
        new (): HTMLStrMenuDividerElement;
    };
    interface HTMLStrMenuItemElement extends Components.StrMenuItem, HTMLStencilElement {
    }
    var HTMLStrMenuItemElement: {
        prototype: HTMLStrMenuItemElement;
        new (): HTMLStrMenuItemElement;
    };
    interface HTMLStrMenuLabelElement extends Components.StrMenuLabel, HTMLStencilElement {
    }
    var HTMLStrMenuLabelElement: {
        prototype: HTMLStrMenuLabelElement;
        new (): HTMLStrMenuLabelElement;
    };
    interface HTMLStrPreviewElement extends Components.StrPreview, HTMLStencilElement {
    }
    var HTMLStrPreviewElement: {
        prototype: HTMLStrPreviewElement;
        new (): HTMLStrPreviewElement;
    };
    interface HTMLStrRadioElement extends Components.StrRadio, HTMLStencilElement {
    }
    var HTMLStrRadioElement: {
        prototype: HTMLStrRadioElement;
        new (): HTMLStrRadioElement;
    };
    interface HTMLStrRadioGroupElement extends Components.StrRadioGroup, HTMLStencilElement {
    }
    var HTMLStrRadioGroupElement: {
        prototype: HTMLStrRadioGroupElement;
        new (): HTMLStrRadioGroupElement;
    };
    interface HTMLStrRouterElement extends Components.StrRouter, HTMLStencilElement {
    }
    var HTMLStrRouterElement: {
        prototype: HTMLStrRouterElement;
        new (): HTMLStrRouterElement;
    };
    interface HTMLStrRowElement extends Components.StrRow, HTMLStencilElement {
    }
    var HTMLStrRowElement: {
        prototype: HTMLStrRowElement;
        new (): HTMLStrRowElement;
    };
    interface HTMLStrSearchbarElement extends Components.StrSearchbar, HTMLStencilElement {
    }
    var HTMLStrSearchbarElement: {
        prototype: HTMLStrSearchbarElement;
        new (): HTMLStrSearchbarElement;
    };
    interface HTMLStrSelectElement extends Components.StrSelect, HTMLStencilElement {
    }
    var HTMLStrSelectElement: {
        prototype: HTMLStrSelectElement;
        new (): HTMLStrSelectElement;
    };
    interface HTMLStrSidebarElement extends Components.StrSidebar, HTMLStencilElement {
    }
    var HTMLStrSidebarElement: {
        prototype: HTMLStrSidebarElement;
        new (): HTMLStrSidebarElement;
    };
    interface HTMLStrSpinnerElement extends Components.StrSpinner, HTMLStencilElement {
    }
    var HTMLStrSpinnerElement: {
        prototype: HTMLStrSpinnerElement;
        new (): HTMLStrSpinnerElement;
    };
    interface HTMLStrSplitPaneElement extends Components.StrSplitPane, HTMLStencilElement {
    }
    var HTMLStrSplitPaneElement: {
        prototype: HTMLStrSplitPaneElement;
        new (): HTMLStrSplitPaneElement;
    };
    interface HTMLStrTabElement extends Components.StrTab, HTMLStencilElement {
    }
    var HTMLStrTabElement: {
        prototype: HTMLStrTabElement;
        new (): HTMLStrTabElement;
    };
    interface HTMLStrTabBarElement extends Components.StrTabBar, HTMLStencilElement {
    }
    var HTMLStrTabBarElement: {
        prototype: HTMLStrTabBarElement;
        new (): HTMLStrTabBarElement;
    };
    interface HTMLStrTabButtonElement extends Components.StrTabButton, HTMLStencilElement {
    }
    var HTMLStrTabButtonElement: {
        prototype: HTMLStrTabButtonElement;
        new (): HTMLStrTabButtonElement;
    };
    interface HTMLStrTabsElement extends Components.StrTabs, HTMLStencilElement {
    }
    var HTMLStrTabsElement: {
        prototype: HTMLStrTabsElement;
        new (): HTMLStrTabsElement;
    };
    interface HTMLStrTagElement extends Components.StrTag, HTMLStencilElement {
    }
    var HTMLStrTagElement: {
        prototype: HTMLStrTagElement;
        new (): HTMLStrTagElement;
    };
    interface HTMLStrTextareaElement extends Components.StrTextarea, HTMLStencilElement {
    }
    var HTMLStrTextareaElement: {
        prototype: HTMLStrTextareaElement;
        new (): HTMLStrTextareaElement;
    };
    interface HTMLStrToolBarElement extends Components.StrToolBar, HTMLStencilElement {
    }
    var HTMLStrToolBarElement: {
        prototype: HTMLStrToolBarElement;
        new (): HTMLStrToolBarElement;
    };
    interface HTMLStrToolButtonElement extends Components.StrToolButton, HTMLStencilElement {
    }
    var HTMLStrToolButtonElement: {
        prototype: HTMLStrToolButtonElement;
        new (): HTMLStrToolButtonElement;
    };
    interface HTMLStrToolZoomElement extends Components.StrToolZoom, HTMLStencilElement {
    }
    var HTMLStrToolZoomElement: {
        prototype: HTMLStrToolZoomElement;
        new (): HTMLStrToolZoomElement;
    };
    interface HTMLStrZoomElement extends Components.StrZoom, HTMLStencilElement {
    }
    var HTMLStrZoomElement: {
        prototype: HTMLStrZoomElement;
        new (): HTMLStrZoomElement;
    };
    interface HTMLElementTagNameMap {
        "str-addon-actions": HTMLStrAddonActionsElement;
        "str-addon-controls": HTMLStrAddonControlsElement;
        "str-addons": HTMLStrAddonsElement;
        "str-app": HTMLStrAppElement;
        "str-badge": HTMLStrBadgeElement;
        "str-button": HTMLStrButtonElement;
        "str-checkbox": HTMLStrCheckboxElement;
        "str-col": HTMLStrColElement;
        "str-dropdown": HTMLStrDropdownElement;
        "str-footer": HTMLStrFooterElement;
        "str-grid": HTMLStrGridElement;
        "str-group": HTMLStrGroupElement;
        "str-icon": HTMLStrIconElement;
        "str-input": HTMLStrInputElement;
        "str-label": HTMLStrLabelElement;
        "str-menu": HTMLStrMenuElement;
        "str-menu-divider": HTMLStrMenuDividerElement;
        "str-menu-item": HTMLStrMenuItemElement;
        "str-menu-label": HTMLStrMenuLabelElement;
        "str-preview": HTMLStrPreviewElement;
        "str-radio": HTMLStrRadioElement;
        "str-radio-group": HTMLStrRadioGroupElement;
        "str-router": HTMLStrRouterElement;
        "str-row": HTMLStrRowElement;
        "str-searchbar": HTMLStrSearchbarElement;
        "str-select": HTMLStrSelectElement;
        "str-sidebar": HTMLStrSidebarElement;
        "str-spinner": HTMLStrSpinnerElement;
        "str-split-pane": HTMLStrSplitPaneElement;
        "str-tab": HTMLStrTabElement;
        "str-tab-bar": HTMLStrTabBarElement;
        "str-tab-button": HTMLStrTabButtonElement;
        "str-tabs": HTMLStrTabsElement;
        "str-tag": HTMLStrTagElement;
        "str-textarea": HTMLStrTextareaElement;
        "str-tool-bar": HTMLStrToolBarElement;
        "str-tool-button": HTMLStrToolButtonElement;
        "str-tool-zoom": HTMLStrToolZoomElement;
        "str-zoom": HTMLStrZoomElement;
    }
}
declare namespace LocalJSX {
    interface StrAddonActions {
    }
    interface StrAddonControls {
    }
    interface StrAddons {
    }
    interface StrApp {
        /**
          * Story Modules
         */
        "modules"?: StoryModules;
        "onStrChange"?: (event: CustomEvent<StoryComponent>) => void;
        "onStrContextChange"?: (event: CustomEvent<StoryContext>) => void;
        /**
          * Story Modules
         */
        "store"?: AppState;
    }
    interface StrBadge {
        /**
          * The badge's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The badge's type.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StrButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret"?: boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle"?: boolean;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled"?: boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to.
         */
        "href"?: string | undefined;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading"?: boolean;
        /**
          * Emitted when the button loses focus.
         */
        "onStrBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the button has focus.
         */
        "onStrFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill"?: boolean;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel"?: string | undefined;
        /**
          * The button's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Specifies where to display the linked URL. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target"?: string | undefined;
        /**
          * The type of the button.
         */
        "type"?: 'submit' | 'reset' | 'button';
        /**
          * The different variants. The options are: `"default"`, `"primary"`, `"secondary"`, `"danger"`, and `"plain"`.
         */
        "variant"?: 'default' | 'primary' | 'secondary' | 'danger' | 'plain';
    }
    interface StrCheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled"?: boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid"?: boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onStrBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onStrChange"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStrFocus"?: (event: CustomEvent<void>) => void;
        /**
          * The checkbox's value attribute.
         */
        "value"?: string;
    }
    interface StrCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StrDropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect"?: boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement"?: HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance"?: number;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist"?: boolean;
        /**
          * Emitted after the dropdown closes and all transitions are complete.
         */
        "onStrAfterHide"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted after the dropdown opens and all transitions are complete.
         */
        "onStrAfterShow"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the dropdown closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onStrHide"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onStrShow"?: (event: CustomEvent<void>) => void;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding"?: number;
    }
    interface StrFooter {
    }
    interface StrGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed"?: boolean;
    }
    interface StrGroup {
        /**
          * Render the fields horizontal instead of vertical
         */
        "horizontal"?: boolean;
        /**
          * The field group label. Recommended for proper accessibility. Alternatively, you can use the label slot.
         */
        "label"?: string;
    }
    interface StrIcon {
        /**
          * Icon name
         */
        "name"?: string;
    }
    interface StrInput {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete"?: AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `stroies-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * Set to true to disable the input control.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "helpText"?: string;
        /**
          * The input's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid"?: boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The inputs's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * The input's name.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onStroiesBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onStroiesChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onStroiesClear"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStroiesFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onStroiesInput"?: (event: CustomEvent<any>) => void;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword"?: boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface StrLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StrMenu {
        /**
          * Emitted when a menu item is selected.
         */
        "onStrSelect"?: (event: CustomEvent<{ item: HTMLStrMenuItemElement }>) => void;
    }
    interface StrMenuDivider {
    }
    interface StrMenuItem {
        /**
          * Set to true to draw the item in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to draw the menu item in a disabled state.
         */
        "disabled"?: boolean;
        /**
          * A unique value to store in the menu item. This can be used as a way to identify menu items when selected.
         */
        "value"?: string;
    }
    interface StrMenuLabel {
    }
    interface StrPreview {
    }
    interface StrRadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled"?: boolean;
        /**
          * Emitted when the control loses focus.
         */
        "onStrBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStrFocus"?: (event: CustomEvent<any>) => void;
        /**
          * The radio's value attribute.
         */
        "value"?: string;
    }
    interface StrRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection"?: boolean;
        /**
          * Render the radios horizontal instead of vertical
         */
        "horizontal"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid"?: boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The radio group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the value has changed.
         */
        "onStrChange"?: (event: CustomEvent<any>) => void;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface StrRouter {
    }
    interface StrRow {
    }
    interface StrSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon"?: string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Emitted when the input loses focus.
         */
        "onStrBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the cancel button is clicked.
         */
        "onStrCancel"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onStrChange"?: (event: CustomEvent<SearchbarChangeEventDetail>) => void;
        /**
          * Emitted when the clear input button is clicked.
         */
        "onStrClear"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onStrFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onStrInput"?: (event: CustomEvent<KeyboardEvent>) => void;
        /**
          * Emitted when the styles change.
         */
        "onStrStyle"?: (event: CustomEvent<StyleEventDetail>) => void;
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder"?: string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton"?: 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton"?: 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type"?: 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StrSelect {
        /**
          * Set to true to add a clear button when the select is populated.
         */
        "clearable"?: boolean;
        /**
          * Set to true to disable the select control.
         */
        "disabled"?: boolean;
        /**
          * The select's help text. Alternatively, you can use the help-text slot.
         */
        "helpText"?: string;
        /**
          * Enable this option to prevent the panel from being clipped when the component is placed inside a container with `overflow: auto|scroll`.
         */
        "hoist"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid"?: boolean;
        /**
          * The select's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The select's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The maximum number of tags to show when `multiple` is true. After the maximum, "+n" will be shown to indicate the number of additional items that are selected. Set to -1 to remove the limit.
         */
        "maxTagsVisible"?: number;
        /**
          * Set to true to enable multiselect.
         */
        "multiple"?: boolean;
        /**
          * The select's name.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onStrBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onStrChange"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStrFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style select with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The select's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * The select's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The value of the control. This will be a string or an array depending on `multiple`.
         */
        "value"?: string | Array<string>;
    }
    interface StrSidebar {
    }
    interface StrSpinner {
    }
    interface StrSplitPane {
        "defaultSize"?: number;
        "isResizing"?: boolean;
        "minSize"?: number;
        "onStrSizeChange"?: (event: CustomEvent<number>) => void;
        "split"?: "horizontal" | "vertical";
    }
    interface StrTab {
        "active"?: boolean;
        /**
          * A tab id must be provided for each `str-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StrTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        "onStrTabBarChange"?: (event: CustomEvent<TabBarChangedEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StrTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled"?: boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * Emitted when the tab bar is clicked
         */
        "onStrTabButtonClick"?: (event: CustomEvent<TabButtonClickEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selected"?: boolean;
        /**
          * A tab id must be provided for each `str-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StrTabs {
    }
    interface StrTag {
        /**
          * Set to true to make the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Emitted when the clear button is activated.
         */
        "onStrClear"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface StrTextarea {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `str-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * Set to true to disable the textarea.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The textarea's help text. Alternatively, you can use the help-text slot.
         */
        "helpText"?: string;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid"?: boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The textarea's label. Alternatively, you can use the label slot.
         */
        "label"?: string | undefined;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength"?: number;
        /**
          * The textarea's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the textarea loses focus.
         */
        "onStrBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the textarea's value changes.
         */
        "onStrChange"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the textarea has focus.
         */
        "onStrFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the textarea receives input.
         */
        "onStrInput"?: (event: CustomEvent<void>) => void;
        /**
          * The textarea's placeholder text.
         */
        "placeholder"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize"?: 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows"?: number;
        /**
          * The textarea's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * The textarea's value attribute.
         */
        "value"?: string;
    }
    interface StrToolBar {
    }
    interface StrToolButton {
        /**
          * command property
         */
        "command"?: Commands;
        /**
          * disabled property
         */
        "disabled"?: boolean;
        /**
          * icon property
         */
        "icon"?: string;
        /**
          * Action Event
         */
        "onStrAction"?: (event: CustomEvent<ToolEvent>) => void;
    }
    interface StrToolZoom {
    }
    interface StrZoom {
        "zoom"?: number;
    }
    interface IntrinsicElements {
        "str-addon-actions": StrAddonActions;
        "str-addon-controls": StrAddonControls;
        "str-addons": StrAddons;
        "str-app": StrApp;
        "str-badge": StrBadge;
        "str-button": StrButton;
        "str-checkbox": StrCheckbox;
        "str-col": StrCol;
        "str-dropdown": StrDropdown;
        "str-footer": StrFooter;
        "str-grid": StrGrid;
        "str-group": StrGroup;
        "str-icon": StrIcon;
        "str-input": StrInput;
        "str-label": StrLabel;
        "str-menu": StrMenu;
        "str-menu-divider": StrMenuDivider;
        "str-menu-item": StrMenuItem;
        "str-menu-label": StrMenuLabel;
        "str-preview": StrPreview;
        "str-radio": StrRadio;
        "str-radio-group": StrRadioGroup;
        "str-router": StrRouter;
        "str-row": StrRow;
        "str-searchbar": StrSearchbar;
        "str-select": StrSelect;
        "str-sidebar": StrSidebar;
        "str-spinner": StrSpinner;
        "str-split-pane": StrSplitPane;
        "str-tab": StrTab;
        "str-tab-bar": StrTabBar;
        "str-tab-button": StrTabButton;
        "str-tabs": StrTabs;
        "str-tag": StrTag;
        "str-textarea": StrTextarea;
        "str-tool-bar": StrToolBar;
        "str-tool-button": StrToolButton;
        "str-tool-zoom": StrToolZoom;
        "str-zoom": StrZoom;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "str-addon-actions": LocalJSX.StrAddonActions & JSXBase.HTMLAttributes<HTMLStrAddonActionsElement>;
            "str-addon-controls": LocalJSX.StrAddonControls & JSXBase.HTMLAttributes<HTMLStrAddonControlsElement>;
            "str-addons": LocalJSX.StrAddons & JSXBase.HTMLAttributes<HTMLStrAddonsElement>;
            "str-app": LocalJSX.StrApp & JSXBase.HTMLAttributes<HTMLStrAppElement>;
            "str-badge": LocalJSX.StrBadge & JSXBase.HTMLAttributes<HTMLStrBadgeElement>;
            "str-button": LocalJSX.StrButton & JSXBase.HTMLAttributes<HTMLStrButtonElement>;
            "str-checkbox": LocalJSX.StrCheckbox & JSXBase.HTMLAttributes<HTMLStrCheckboxElement>;
            "str-col": LocalJSX.StrCol & JSXBase.HTMLAttributes<HTMLStrColElement>;
            "str-dropdown": LocalJSX.StrDropdown & JSXBase.HTMLAttributes<HTMLStrDropdownElement>;
            "str-footer": LocalJSX.StrFooter & JSXBase.HTMLAttributes<HTMLStrFooterElement>;
            "str-grid": LocalJSX.StrGrid & JSXBase.HTMLAttributes<HTMLStrGridElement>;
            "str-group": LocalJSX.StrGroup & JSXBase.HTMLAttributes<HTMLStrGroupElement>;
            "str-icon": LocalJSX.StrIcon & JSXBase.HTMLAttributes<HTMLStrIconElement>;
            "str-input": LocalJSX.StrInput & JSXBase.HTMLAttributes<HTMLStrInputElement>;
            "str-label": LocalJSX.StrLabel & JSXBase.HTMLAttributes<HTMLStrLabelElement>;
            "str-menu": LocalJSX.StrMenu & JSXBase.HTMLAttributes<HTMLStrMenuElement>;
            "str-menu-divider": LocalJSX.StrMenuDivider & JSXBase.HTMLAttributes<HTMLStrMenuDividerElement>;
            "str-menu-item": LocalJSX.StrMenuItem & JSXBase.HTMLAttributes<HTMLStrMenuItemElement>;
            "str-menu-label": LocalJSX.StrMenuLabel & JSXBase.HTMLAttributes<HTMLStrMenuLabelElement>;
            "str-preview": LocalJSX.StrPreview & JSXBase.HTMLAttributes<HTMLStrPreviewElement>;
            "str-radio": LocalJSX.StrRadio & JSXBase.HTMLAttributes<HTMLStrRadioElement>;
            "str-radio-group": LocalJSX.StrRadioGroup & JSXBase.HTMLAttributes<HTMLStrRadioGroupElement>;
            "str-router": LocalJSX.StrRouter & JSXBase.HTMLAttributes<HTMLStrRouterElement>;
            "str-row": LocalJSX.StrRow & JSXBase.HTMLAttributes<HTMLStrRowElement>;
            "str-searchbar": LocalJSX.StrSearchbar & JSXBase.HTMLAttributes<HTMLStrSearchbarElement>;
            "str-select": LocalJSX.StrSelect & JSXBase.HTMLAttributes<HTMLStrSelectElement>;
            "str-sidebar": LocalJSX.StrSidebar & JSXBase.HTMLAttributes<HTMLStrSidebarElement>;
            "str-spinner": LocalJSX.StrSpinner & JSXBase.HTMLAttributes<HTMLStrSpinnerElement>;
            "str-split-pane": LocalJSX.StrSplitPane & JSXBase.HTMLAttributes<HTMLStrSplitPaneElement>;
            "str-tab": LocalJSX.StrTab & JSXBase.HTMLAttributes<HTMLStrTabElement>;
            "str-tab-bar": LocalJSX.StrTabBar & JSXBase.HTMLAttributes<HTMLStrTabBarElement>;
            "str-tab-button": LocalJSX.StrTabButton & JSXBase.HTMLAttributes<HTMLStrTabButtonElement>;
            "str-tabs": LocalJSX.StrTabs & JSXBase.HTMLAttributes<HTMLStrTabsElement>;
            "str-tag": LocalJSX.StrTag & JSXBase.HTMLAttributes<HTMLStrTagElement>;
            "str-textarea": LocalJSX.StrTextarea & JSXBase.HTMLAttributes<HTMLStrTextareaElement>;
            "str-tool-bar": LocalJSX.StrToolBar & JSXBase.HTMLAttributes<HTMLStrToolBarElement>;
            "str-tool-button": LocalJSX.StrToolButton & JSXBase.HTMLAttributes<HTMLStrToolButtonElement>;
            "str-tool-zoom": LocalJSX.StrToolZoom & JSXBase.HTMLAttributes<HTMLStrToolZoomElement>;
            "str-zoom": LocalJSX.StrZoom & JSXBase.HTMLAttributes<HTMLStrZoomElement>;
        }
    }
}
