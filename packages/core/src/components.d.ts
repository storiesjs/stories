/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { Addon, Color, Commands, SearchbarChangeEventDetail, StoryComponent, StoryContext, StoryModules, StyleEventDetail, TabBarChangedEventDetail, TabButtonClickEventDetail, TabButtonLayout, TextFieldTypes, ToolEvent } from "./types";
import { AppState } from "./store";
import { AutocompleteTypes } from "./interface";
import { RadioGroupChangeEventDetail } from "./components/radio-group/radio-group-interface";
export namespace Components {
    interface StoriesAddonActions {
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
    }
    interface StoriesAddonControls {
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
    }
    interface StoriesAddons {
        "findAddon": (id: string) => Promise<Addon>;
        "registerAddon": (addon: Addon) => Promise<void>;
        "storyContextChanged": (story: StoryComponent, context: StoryContext) => Promise<void>;
        "unregisterAddon": (addon: Addon) => Promise<void>;
    }
    interface StoriesApp {
        /**
          * Story Modules
         */
        "modules": StoryModules;
        /**
          * Story Modules
         */
        "store": AppState;
    }
    interface StoriesBadge {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
    }
    interface StoriesButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret": boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle": boolean;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled": boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to.
         */
        "href": string | undefined;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading": boolean;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill": boolean;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel": string | undefined;
        /**
          * Removes focus from the button.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the button.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The button's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Specifies where to display the linked URL. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target": string | undefined;
        /**
          * The type of the button.
         */
        "type": 'submit' | 'reset' | 'button';
        /**
          * The different variants. The options are: `"default"`, `"primary"`, `"secondary"`, `"danger"`, and `"plain"`.
         */
        "variant"?: 'default' | 'primary' | 'secondary' | 'danger' | 'plain';
    }
    interface StoriesButtons {
        /**
          * If true, buttons will disappear when its parent toolbar has fully collapsed if the toolbar is not the first toolbar. If the toolbar is the first toolbar, the buttons will be hidden and will only be shown once all toolbars have fully collapsed.
         */
        "collapse": boolean;
    }
    interface StoriesCheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled": boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid": boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Removes focus from the checkbox.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the checkbox.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The checkbox's value attribute.
         */
        "value": string;
    }
    interface StoriesCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StoriesFooter {
    }
    interface StoriesGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed": boolean;
    }
    interface StoriesGroup {
        /**
          * Render the fields horizontal instead of vertical
         */
        "horizontal": boolean;
        /**
          * The field group label. Recommended for proper accessibility. Alternatively, you can use the label slot.
         */
        "label": string;
    }
    interface StoriesIcon {
        /**
          * Icon name
         */
        "name": string;
    }
    interface StoriesInput {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete": AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `gr-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * Set to true to disable the input control.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "helpText": string;
        /**
          * The input's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid": boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The inputs's label. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength": number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * The input's name.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * Removes focus from the input.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword": boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface StoriesLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StoriesPreview {
    }
    interface StoriesRadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled": boolean;
        /**
          * Removes focus from the radio.
         */
        "removeFocus": () => Promise<void>;
        "setButtonTabindex": (value: number) => Promise<void>;
        /**
          * Sets focus on the radio.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
        /**
          * The radio's value attribute.
         */
        "value": string;
    }
    interface StoriesRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection": boolean;
        /**
          * Render the radios horizontal instead of vertical
         */
        "horizontal": boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid": boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText": string;
        /**
          * The radio group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator": boolean;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface StoriesRouter {
    }
    interface StoriesRow {
    }
    interface StoriesSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon": string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder": string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets focus on the specified `stories-searchbar`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton": 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton": 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type": 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StoriesSidebar {
    }
    interface StoriesSplitPane {
        "defaultSize": number;
        "isResizing": boolean;
        "minSize": number;
        "split": "horizontal" | "vertical";
    }
    interface StoriesTab {
        "active": boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StoriesTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StoriesTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled": boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * The selected tab component
         */
        "selected": boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StoriesTabs {
        /**
          * Get the currently selected tab.
         */
        "getSelected": () => Promise<string | undefined>;
        /**
          * Get a specific tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "getTab": (tab: string | HTMLStoriesTabElement) => Promise<HTMLStoriesTabElement | undefined>;
        /**
          * Select a tab by the value of its `tab` property or an element reference.
          * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
         */
        "select": (tab: string | HTMLStoriesTabElement) => Promise<boolean>;
    }
    interface StoriesToolBar {
    }
    interface StoriesToolButton {
        /**
          * command property
         */
        "command": Commands;
        /**
          * disabled property
         */
        "disabled": boolean;
        /**
          * icon property
         */
        "icon": string;
    }
    interface StoriesToolZoom {
    }
    interface StoriesZoom {
        "zoom": number;
    }
}
declare global {
    interface HTMLStoriesAddonActionsElement extends Components.StoriesAddonActions, HTMLStencilElement {
    }
    var HTMLStoriesAddonActionsElement: {
        prototype: HTMLStoriesAddonActionsElement;
        new (): HTMLStoriesAddonActionsElement;
    };
    interface HTMLStoriesAddonControlsElement extends Components.StoriesAddonControls, HTMLStencilElement {
    }
    var HTMLStoriesAddonControlsElement: {
        prototype: HTMLStoriesAddonControlsElement;
        new (): HTMLStoriesAddonControlsElement;
    };
    interface HTMLStoriesAddonsElement extends Components.StoriesAddons, HTMLStencilElement {
    }
    var HTMLStoriesAddonsElement: {
        prototype: HTMLStoriesAddonsElement;
        new (): HTMLStoriesAddonsElement;
    };
    interface HTMLStoriesAppElement extends Components.StoriesApp, HTMLStencilElement {
    }
    var HTMLStoriesAppElement: {
        prototype: HTMLStoriesAppElement;
        new (): HTMLStoriesAppElement;
    };
    interface HTMLStoriesBadgeElement extends Components.StoriesBadge, HTMLStencilElement {
    }
    var HTMLStoriesBadgeElement: {
        prototype: HTMLStoriesBadgeElement;
        new (): HTMLStoriesBadgeElement;
    };
    interface HTMLStoriesButtonElement extends Components.StoriesButton, HTMLStencilElement {
    }
    var HTMLStoriesButtonElement: {
        prototype: HTMLStoriesButtonElement;
        new (): HTMLStoriesButtonElement;
    };
    interface HTMLStoriesButtonsElement extends Components.StoriesButtons, HTMLStencilElement {
    }
    var HTMLStoriesButtonsElement: {
        prototype: HTMLStoriesButtonsElement;
        new (): HTMLStoriesButtonsElement;
    };
    interface HTMLStoriesCheckboxElement extends Components.StoriesCheckbox, HTMLStencilElement {
    }
    var HTMLStoriesCheckboxElement: {
        prototype: HTMLStoriesCheckboxElement;
        new (): HTMLStoriesCheckboxElement;
    };
    interface HTMLStoriesColElement extends Components.StoriesCol, HTMLStencilElement {
    }
    var HTMLStoriesColElement: {
        prototype: HTMLStoriesColElement;
        new (): HTMLStoriesColElement;
    };
    interface HTMLStoriesFooterElement extends Components.StoriesFooter, HTMLStencilElement {
    }
    var HTMLStoriesFooterElement: {
        prototype: HTMLStoriesFooterElement;
        new (): HTMLStoriesFooterElement;
    };
    interface HTMLStoriesGridElement extends Components.StoriesGrid, HTMLStencilElement {
    }
    var HTMLStoriesGridElement: {
        prototype: HTMLStoriesGridElement;
        new (): HTMLStoriesGridElement;
    };
    interface HTMLStoriesGroupElement extends Components.StoriesGroup, HTMLStencilElement {
    }
    var HTMLStoriesGroupElement: {
        prototype: HTMLStoriesGroupElement;
        new (): HTMLStoriesGroupElement;
    };
    interface HTMLStoriesIconElement extends Components.StoriesIcon, HTMLStencilElement {
    }
    var HTMLStoriesIconElement: {
        prototype: HTMLStoriesIconElement;
        new (): HTMLStoriesIconElement;
    };
    interface HTMLStoriesInputElement extends Components.StoriesInput, HTMLStencilElement {
    }
    var HTMLStoriesInputElement: {
        prototype: HTMLStoriesInputElement;
        new (): HTMLStoriesInputElement;
    };
    interface HTMLStoriesLabelElement extends Components.StoriesLabel, HTMLStencilElement {
    }
    var HTMLStoriesLabelElement: {
        prototype: HTMLStoriesLabelElement;
        new (): HTMLStoriesLabelElement;
    };
    interface HTMLStoriesPreviewElement extends Components.StoriesPreview, HTMLStencilElement {
    }
    var HTMLStoriesPreviewElement: {
        prototype: HTMLStoriesPreviewElement;
        new (): HTMLStoriesPreviewElement;
    };
    interface HTMLStoriesRadioElement extends Components.StoriesRadio, HTMLStencilElement {
    }
    var HTMLStoriesRadioElement: {
        prototype: HTMLStoriesRadioElement;
        new (): HTMLStoriesRadioElement;
    };
    interface HTMLStoriesRadioGroupElement extends Components.StoriesRadioGroup, HTMLStencilElement {
    }
    var HTMLStoriesRadioGroupElement: {
        prototype: HTMLStoriesRadioGroupElement;
        new (): HTMLStoriesRadioGroupElement;
    };
    interface HTMLStoriesRouterElement extends Components.StoriesRouter, HTMLStencilElement {
    }
    var HTMLStoriesRouterElement: {
        prototype: HTMLStoriesRouterElement;
        new (): HTMLStoriesRouterElement;
    };
    interface HTMLStoriesRowElement extends Components.StoriesRow, HTMLStencilElement {
    }
    var HTMLStoriesRowElement: {
        prototype: HTMLStoriesRowElement;
        new (): HTMLStoriesRowElement;
    };
    interface HTMLStoriesSearchbarElement extends Components.StoriesSearchbar, HTMLStencilElement {
    }
    var HTMLStoriesSearchbarElement: {
        prototype: HTMLStoriesSearchbarElement;
        new (): HTMLStoriesSearchbarElement;
    };
    interface HTMLStoriesSidebarElement extends Components.StoriesSidebar, HTMLStencilElement {
    }
    var HTMLStoriesSidebarElement: {
        prototype: HTMLStoriesSidebarElement;
        new (): HTMLStoriesSidebarElement;
    };
    interface HTMLStoriesSplitPaneElement extends Components.StoriesSplitPane, HTMLStencilElement {
    }
    var HTMLStoriesSplitPaneElement: {
        prototype: HTMLStoriesSplitPaneElement;
        new (): HTMLStoriesSplitPaneElement;
    };
    interface HTMLStoriesTabElement extends Components.StoriesTab, HTMLStencilElement {
    }
    var HTMLStoriesTabElement: {
        prototype: HTMLStoriesTabElement;
        new (): HTMLStoriesTabElement;
    };
    interface HTMLStoriesTabBarElement extends Components.StoriesTabBar, HTMLStencilElement {
    }
    var HTMLStoriesTabBarElement: {
        prototype: HTMLStoriesTabBarElement;
        new (): HTMLStoriesTabBarElement;
    };
    interface HTMLStoriesTabButtonElement extends Components.StoriesTabButton, HTMLStencilElement {
    }
    var HTMLStoriesTabButtonElement: {
        prototype: HTMLStoriesTabButtonElement;
        new (): HTMLStoriesTabButtonElement;
    };
    interface HTMLStoriesTabsElement extends Components.StoriesTabs, HTMLStencilElement {
    }
    var HTMLStoriesTabsElement: {
        prototype: HTMLStoriesTabsElement;
        new (): HTMLStoriesTabsElement;
    };
    interface HTMLStoriesToolBarElement extends Components.StoriesToolBar, HTMLStencilElement {
    }
    var HTMLStoriesToolBarElement: {
        prototype: HTMLStoriesToolBarElement;
        new (): HTMLStoriesToolBarElement;
    };
    interface HTMLStoriesToolButtonElement extends Components.StoriesToolButton, HTMLStencilElement {
    }
    var HTMLStoriesToolButtonElement: {
        prototype: HTMLStoriesToolButtonElement;
        new (): HTMLStoriesToolButtonElement;
    };
    interface HTMLStoriesToolZoomElement extends Components.StoriesToolZoom, HTMLStencilElement {
    }
    var HTMLStoriesToolZoomElement: {
        prototype: HTMLStoriesToolZoomElement;
        new (): HTMLStoriesToolZoomElement;
    };
    interface HTMLStoriesZoomElement extends Components.StoriesZoom, HTMLStencilElement {
    }
    var HTMLStoriesZoomElement: {
        prototype: HTMLStoriesZoomElement;
        new (): HTMLStoriesZoomElement;
    };
    interface HTMLElementTagNameMap {
        "stories-addon-actions": HTMLStoriesAddonActionsElement;
        "stories-addon-controls": HTMLStoriesAddonControlsElement;
        "stories-addons": HTMLStoriesAddonsElement;
        "stories-app": HTMLStoriesAppElement;
        "stories-badge": HTMLStoriesBadgeElement;
        "stories-button": HTMLStoriesButtonElement;
        "stories-buttons": HTMLStoriesButtonsElement;
        "stories-checkbox": HTMLStoriesCheckboxElement;
        "stories-col": HTMLStoriesColElement;
        "stories-footer": HTMLStoriesFooterElement;
        "stories-grid": HTMLStoriesGridElement;
        "stories-group": HTMLStoriesGroupElement;
        "stories-icon": HTMLStoriesIconElement;
        "stories-input": HTMLStoriesInputElement;
        "stories-label": HTMLStoriesLabelElement;
        "stories-preview": HTMLStoriesPreviewElement;
        "stories-radio": HTMLStoriesRadioElement;
        "stories-radio-group": HTMLStoriesRadioGroupElement;
        "stories-router": HTMLStoriesRouterElement;
        "stories-row": HTMLStoriesRowElement;
        "stories-searchbar": HTMLStoriesSearchbarElement;
        "stories-sidebar": HTMLStoriesSidebarElement;
        "stories-split-pane": HTMLStoriesSplitPaneElement;
        "stories-tab": HTMLStoriesTabElement;
        "stories-tab-bar": HTMLStoriesTabBarElement;
        "stories-tab-button": HTMLStoriesTabButtonElement;
        "stories-tabs": HTMLStoriesTabsElement;
        "stories-tool-bar": HTMLStoriesToolBarElement;
        "stories-tool-button": HTMLStoriesToolButtonElement;
        "stories-tool-zoom": HTMLStoriesToolZoomElement;
        "stories-zoom": HTMLStoriesZoomElement;
    }
}
declare namespace LocalJSX {
    interface StoriesAddonActions {
    }
    interface StoriesAddonControls {
    }
    interface StoriesAddons {
    }
    interface StoriesApp {
        /**
          * Story Modules
         */
        "modules"?: StoryModules;
        "onStoryChange"?: (event: CustomEvent<StoryComponent>) => void;
        "onStoryContextChange"?: (event: CustomEvent<StoryContext>) => void;
        /**
          * Story Modules
         */
        "store"?: AppState;
    }
    interface StoriesBadge {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
    }
    interface StoriesButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret"?: boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle"?: boolean;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled"?: boolean;
        /**
          * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
         */
        "expand"?: 'full' | 'block';
        /**
          * Contains a URL or a URL fragment that the hyperlink points to.
         */
        "href"?: string | undefined;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading"?: boolean;
        /**
          * Emitted when the button loses focus.
         */
        "onStories-blur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the button has focus.
         */
        "onStories-focus"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill"?: boolean;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel"?: string | undefined;
        /**
          * The button's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Specifies where to display the linked URL. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target"?: string | undefined;
        /**
          * The type of the button.
         */
        "type"?: 'submit' | 'reset' | 'button';
        /**
          * The different variants. The options are: `"default"`, `"primary"`, `"secondary"`, `"danger"`, and `"plain"`.
         */
        "variant"?: 'default' | 'primary' | 'secondary' | 'danger' | 'plain';
    }
    interface StoriesButtons {
        /**
          * If true, buttons will disappear when its parent toolbar has fully collapsed if the toolbar is not the first toolbar. If the toolbar is the first toolbar, the buttons will be hidden and will only be shown once all toolbars have fully collapsed.
         */
        "collapse"?: boolean;
    }
    interface StoriesCheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled"?: boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid"?: boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onStories-blur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onStories-change"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStories-focus"?: (event: CustomEvent<void>) => void;
        /**
          * The checkbox's value attribute.
         */
        "value"?: string;
    }
    interface StoriesCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface StoriesFooter {
    }
    interface StoriesGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed"?: boolean;
    }
    interface StoriesGroup {
        /**
          * Render the fields horizontal instead of vertical
         */
        "horizontal"?: boolean;
        /**
          * The field group label. Recommended for proper accessibility. Alternatively, you can use the label slot.
         */
        "label"?: string;
    }
    interface StoriesIcon {
        /**
          * Icon name
         */
        "name"?: string;
    }
    interface StoriesInput {
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete"?: AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `gr-change` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * Set to true to disable the input control.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * The input's help text. Alternatively, you can use the help-text slot.
         */
        "helpText"?: string;
        /**
          * The input's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text instead of the help text
         */
        "invalid"?: boolean;
        /**
          * The input's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The inputs's label. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * Specifies how many characters are allowed.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * The input's name.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onGr-blur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onGr-change"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onGr-clear"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onGr-focus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onGr-input"?: (event: CustomEvent<void>) => void;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword"?: boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface StoriesLabel {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * The position determines where and how the label behaves inside an item.
         */
        "position"?: 'fixed' | 'stacked' | 'floating';
    }
    interface StoriesPreview {
    }
    interface StoriesRadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled"?: boolean;
        /**
          * Emitted when the control loses focus.
         */
        "onStories-blur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onStories-focus"?: (event: CustomEvent<any>) => void;
        /**
          * The radio's value attribute.
         */
        "value"?: string;
    }
    interface StoriesRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection"?: boolean;
        /**
          * Render the radios horizontal instead of vertical
         */
        "horizontal"?: boolean;
        /**
          * Set to true to indicate this field is invalid. Will display the invalid text.
         */
        "invalid"?: boolean;
        /**
          * The radio group's invalid text. Alternatively, you can use the invalid-text slot.
         */
        "invalidText"?: string;
        /**
          * The radio group label. Required for proper accessibility. Alternatively, you can use the label slot.
         */
        "label"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the value has changed.
         */
        "onStories-change"?: (event: CustomEvent<RadioGroupChangeEventDetail>) => void;
        /**
          * Set to true to display a required indicator, adds an asterisk to label
         */
        "requiredIndicator"?: boolean;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface StoriesRouter {
    }
    interface StoriesRow {
    }
    interface StoriesSearchbar {
        /**
          * Set the cancel button icon. Only applies to `md` mode. Defaults to `"arrow-back-sharp"`.
         */
        "cancelButtonIcon"?: string;
        /**
          * Set the clear icon. Defaults to `"close-circle"` for `ios` and `"close-sharp"` for `md`.
         */
        "clearIcon"?: string;
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * Emitted when the input loses focus.
         */
        "onStoriesBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the cancel button is clicked.
         */
        "onStoriesCancel"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onStoriesChange"?: (event: CustomEvent<SearchbarChangeEventDetail>) => void;
        /**
          * Emitted when the clear input button is clicked.
         */
        "onStoriesClear"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onStoriesFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onStoriesInput"?: (event: CustomEvent<KeyboardEvent>) => void;
        /**
          * Emitted when the styles change.
         */
        "onStoriesStyle"?: (event: CustomEvent<StyleEventDetail>) => void;
        /**
          * Set the input's placeholder. `placeholder` can accept either plaintext or HTML as a string. To display characters normally reserved for HTML, they must be escaped. For example `<Stories>` would become `&lt;Stories&gt;`
         */
        "placeholder"?: string;
        /**
          * The icon to use as the search icon. Defaults to `"search-outline"` in `ios` mode and `"search-sharp"` in `md` mode.
         */
        "searchIcon"?: string;
        /**
          * Sets the behavior for the cancel button. Defaults to `"never"`. Setting to `"focus"` shows the cancel button on focus. Setting to `"never"` hides the cancel button. Setting to `"always"` shows the cancel button regardless of focus state.
         */
        "showCancelButton"?: 'never' | 'focus' | 'always';
        /**
          * Sets the behavior for the clear button. Defaults to `"focus"`. Setting to `"focus"` shows the clear button on focus if the input is not empty. Setting to `"never"` hides the clear button. Setting to `"always"` shows the clear button regardless of focus state, but only if the input is not empty.
         */
        "showClearButton"?: 'never' | 'focus' | 'always';
        /**
          * Set the type of the input.
         */
        "type"?: 'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url';
        /**
          * the value of the searchbar.
         */
        "value"?: string | null;
    }
    interface StoriesSidebar {
    }
    interface StoriesSplitPane {
        "defaultSize"?: number;
        "isResizing"?: boolean;
        "minSize"?: number;
        "onStoriesSizeChange"?: (event: CustomEvent<number>) => void;
        "split"?: "horizontal" | "vertical";
    }
    interface StoriesTab {
        "active"?: boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab": string;
    }
    interface StoriesTabBar {
        /**
          * The color to use from your application's color palette. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information on colors, see [theming](/docs/theming/basics).
         */
        "color"?: Color;
        "onStoriesTabBarChange"?: (event: CustomEvent<TabBarChangedEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selectedTab"?: string;
    }
    interface StoriesTabButton {
        /**
          * If `true`, the user cannot interact with the tab button.
         */
        "disabled"?: boolean;
        /**
          * Set the layout of the text and icon in the tab bar. It defaults to `'icon-start'`.
         */
        "layout"?: TabButtonLayout;
        /**
          * Emitted when the tab bar is clicked
         */
        "onStoriesTabButtonClick"?: (event: CustomEvent<TabButtonClickEventDetail>) => void;
        /**
          * The selected tab component
         */
        "selected"?: boolean;
        /**
          * A tab id must be provided for each `stories-tab`. It's used internally to reference the selected tab or by the router to switch between them.
         */
        "tab"?: string;
    }
    interface StoriesTabs {
    }
    interface StoriesToolBar {
    }
    interface StoriesToolButton {
        /**
          * command property
         */
        "command"?: Commands;
        /**
          * disabled property
         */
        "disabled"?: boolean;
        /**
          * icon property
         */
        "icon"?: string;
        /**
          * Action Event
         */
        "onStoriesAction"?: (event: CustomEvent<ToolEvent>) => void;
    }
    interface StoriesToolZoom {
    }
    interface StoriesZoom {
        "zoom"?: number;
    }
    interface IntrinsicElements {
        "stories-addon-actions": StoriesAddonActions;
        "stories-addon-controls": StoriesAddonControls;
        "stories-addons": StoriesAddons;
        "stories-app": StoriesApp;
        "stories-badge": StoriesBadge;
        "stories-button": StoriesButton;
        "stories-buttons": StoriesButtons;
        "stories-checkbox": StoriesCheckbox;
        "stories-col": StoriesCol;
        "stories-footer": StoriesFooter;
        "stories-grid": StoriesGrid;
        "stories-group": StoriesGroup;
        "stories-icon": StoriesIcon;
        "stories-input": StoriesInput;
        "stories-label": StoriesLabel;
        "stories-preview": StoriesPreview;
        "stories-radio": StoriesRadio;
        "stories-radio-group": StoriesRadioGroup;
        "stories-router": StoriesRouter;
        "stories-row": StoriesRow;
        "stories-searchbar": StoriesSearchbar;
        "stories-sidebar": StoriesSidebar;
        "stories-split-pane": StoriesSplitPane;
        "stories-tab": StoriesTab;
        "stories-tab-bar": StoriesTabBar;
        "stories-tab-button": StoriesTabButton;
        "stories-tabs": StoriesTabs;
        "stories-tool-bar": StoriesToolBar;
        "stories-tool-button": StoriesToolButton;
        "stories-tool-zoom": StoriesToolZoom;
        "stories-zoom": StoriesZoom;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "stories-addon-actions": LocalJSX.StoriesAddonActions & JSXBase.HTMLAttributes<HTMLStoriesAddonActionsElement>;
            "stories-addon-controls": LocalJSX.StoriesAddonControls & JSXBase.HTMLAttributes<HTMLStoriesAddonControlsElement>;
            "stories-addons": LocalJSX.StoriesAddons & JSXBase.HTMLAttributes<HTMLStoriesAddonsElement>;
            "stories-app": LocalJSX.StoriesApp & JSXBase.HTMLAttributes<HTMLStoriesAppElement>;
            "stories-badge": LocalJSX.StoriesBadge & JSXBase.HTMLAttributes<HTMLStoriesBadgeElement>;
            "stories-button": LocalJSX.StoriesButton & JSXBase.HTMLAttributes<HTMLStoriesButtonElement>;
            "stories-buttons": LocalJSX.StoriesButtons & JSXBase.HTMLAttributes<HTMLStoriesButtonsElement>;
            "stories-checkbox": LocalJSX.StoriesCheckbox & JSXBase.HTMLAttributes<HTMLStoriesCheckboxElement>;
            "stories-col": LocalJSX.StoriesCol & JSXBase.HTMLAttributes<HTMLStoriesColElement>;
            "stories-footer": LocalJSX.StoriesFooter & JSXBase.HTMLAttributes<HTMLStoriesFooterElement>;
            "stories-grid": LocalJSX.StoriesGrid & JSXBase.HTMLAttributes<HTMLStoriesGridElement>;
            "stories-group": LocalJSX.StoriesGroup & JSXBase.HTMLAttributes<HTMLStoriesGroupElement>;
            "stories-icon": LocalJSX.StoriesIcon & JSXBase.HTMLAttributes<HTMLStoriesIconElement>;
            "stories-input": LocalJSX.StoriesInput & JSXBase.HTMLAttributes<HTMLStoriesInputElement>;
            "stories-label": LocalJSX.StoriesLabel & JSXBase.HTMLAttributes<HTMLStoriesLabelElement>;
            "stories-preview": LocalJSX.StoriesPreview & JSXBase.HTMLAttributes<HTMLStoriesPreviewElement>;
            "stories-radio": LocalJSX.StoriesRadio & JSXBase.HTMLAttributes<HTMLStoriesRadioElement>;
            "stories-radio-group": LocalJSX.StoriesRadioGroup & JSXBase.HTMLAttributes<HTMLStoriesRadioGroupElement>;
            "stories-router": LocalJSX.StoriesRouter & JSXBase.HTMLAttributes<HTMLStoriesRouterElement>;
            "stories-row": LocalJSX.StoriesRow & JSXBase.HTMLAttributes<HTMLStoriesRowElement>;
            "stories-searchbar": LocalJSX.StoriesSearchbar & JSXBase.HTMLAttributes<HTMLStoriesSearchbarElement>;
            "stories-sidebar": LocalJSX.StoriesSidebar & JSXBase.HTMLAttributes<HTMLStoriesSidebarElement>;
            "stories-split-pane": LocalJSX.StoriesSplitPane & JSXBase.HTMLAttributes<HTMLStoriesSplitPaneElement>;
            "stories-tab": LocalJSX.StoriesTab & JSXBase.HTMLAttributes<HTMLStoriesTabElement>;
            "stories-tab-bar": LocalJSX.StoriesTabBar & JSXBase.HTMLAttributes<HTMLStoriesTabBarElement>;
            "stories-tab-button": LocalJSX.StoriesTabButton & JSXBase.HTMLAttributes<HTMLStoriesTabButtonElement>;
            "stories-tabs": LocalJSX.StoriesTabs & JSXBase.HTMLAttributes<HTMLStoriesTabsElement>;
            "stories-tool-bar": LocalJSX.StoriesToolBar & JSXBase.HTMLAttributes<HTMLStoriesToolBarElement>;
            "stories-tool-button": LocalJSX.StoriesToolButton & JSXBase.HTMLAttributes<HTMLStoriesToolButtonElement>;
            "stories-tool-zoom": LocalJSX.StoriesToolZoom & JSXBase.HTMLAttributes<HTMLStoriesToolZoomElement>;
            "stories-zoom": LocalJSX.StoriesZoom & JSXBase.HTMLAttributes<HTMLStoriesZoomElement>;
        }
    }
}
